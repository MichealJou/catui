# 行完整显示/消失优化

> **优化日期**: 2026-02-10
> **需求**: 行应该完整地出现和消失，不要裁剪
> **状态**: ✅ 已完成

---

## 🎯 问题描述

### 用户需求

"不能等上一行完全消失了再剪切吗？"

用户希望：
- ✅ 行应该完整地出现和消失
- ✅ 不要显示半截的行
- ✅ 等上一行完全滑出可视区域后，下一行才开始占据位置

### 之前的行为 ❌

```
向下滚动过程：
┌─────────────────┐
│  Row 1 (100%)   │  ← 正常显示
├─────┬───────────┤
│ 80% │            │  ← Row 1 被裁剪，只显示 80%
│ Row 2            │  ← Row 2 开始显示，但被裁剪
├─────┴───────────┤
│  Row 3 (100%)   │  ← 正常显示
└─────────────────┘
```

**问题**：
- Row 1 部分被裁剪
- Row 2 部分可见，给人感觉"不完整"
- 视觉上不够简洁

---

## ✅ 优化方案

### 核心思路

**只渲染完全可见的行**：
- 如果行有任何部分在表头内（y < headerHeight），不渲染
- 只有完全在表头下方的行才渲染
- 让行完整地出现和消失

### 代码实现

**修改位置**: `G2TableRenderer.ts:722-739`

**修改前**:
```typescript
// 跳过完全在表头上方的行
if (y + cellHeight <= headerHeight) {
  return
}

// 处理跨越表头边界的行
let actualY = y
let actualHeight = cellHeight

if (y < headerHeight && y + cellHeight > headerHeight) {
  // 行跨越表头边界，从表头下方开始绘制，裁剪掉表头遮挡的部分
  actualY = headerHeight
  actualHeight = y + cellHeight - headerHeight
}
```

**修改后**:
```typescript
// 跳过部分在表头内的行（让行完整出现/消失）
if (y < headerHeight) {
  return
}

// 不进行裁剪，只渲染完整的行
const actualY = y
const actualHeight = cellHeight
```

### 关键改进

1. **简化逻辑** - 移除复杂的裁剪计算
2. **完整渲染** - 只渲染完全可见的行
3. **自然过渡** - 行自然地出现和消失
4. **代码简洁** - 减少条件判断和复杂度

---

## 🎯 优化效果

### 修改后 ✅

```
向下滚动过程（Row 1 正在滑出）：
┌─────────────────┐
│  Row 1 (100%)   │  ← 完整显示
├─────────────────┤
│  空白区域        │  ← Row 1 完全消失后才有空白
├─────────────────┤
│  Row 2 (100%)   │  ← 完整显示
├─────────────────┤
│  Row 3 (100%)   │  ← 完整显示
└─────────────────┘
```

**效果**：
- ✅ 所有行都是完整显示的
- ✅ 行自然地滑出/滑入
- ✅ 没有半截行
- ✅ 视觉上更简洁

### 优势

| 特性 | 修改前 | 修改后 |
|------|--------|--------|
| **行完整性** | ❌ 有半截行 | ✅ 所有行完整 |
| **视觉简洁** | ❌ 有裁剪 | ✅ 无裁剪 |
| **代码复杂度** | 高（裁剪逻辑） | 低（简单判断） |
| **渲染性能** | 基准 | 相同或更好 |

---

## 📁 修改的文件

### 1. G2TableRenderer.ts

**文件**: `packages/ctable/src/core/G2TableRenderer.ts`

**修改位置**: 第 722-739 行

### 2. G2TableRendererV2.ts

**文件**: `packages/ctable/src/core/G2TableRendererV2.ts`

**修改位置**: 第 312-326 行

**同样的修改** - 简化渲染逻辑，只渲染完整的行

---

## 🔬 技术细节

### 渲染逻辑

**判断条件**:
```typescript
// 如果行有任何部分在表头内，跳过
if (y < headerHeight) {
  return
}

// 如果行完全超出底部，跳过
if (y >= this.height) {
  return
}

// 渲染完整的行
const actualY = y
const actualHeight = cellHeight
```

### Canvas 自动裁剪

虽然我们跳过了部分可见的行，但 Canvas 仍然会自动裁剪：
- 超出 Canvas 底部的内容会被自动裁剪
- 我们不需要手动处理底部边界

### 缓冲区的作用

虚拟滚动的缓冲区（上下各 10 行）确保：
- 快速滚动时不会出现白屏
- 行在进入可视区域前就已经准备好
- 滚动更加流畅

---

## 📊 性能影响

### 修改前 vs 修改后

| 指标 | 修改前 | 修改后 | 说明 |
|------|--------|--------|------|
| **视觉效果** | 有半截行 | 完整的行 | 用户体验 ✅ |
| **代码复杂度** | 高（裁剪逻辑） | 低（简单判断） | 可维护性 ✅ |
| **渲染性能** | 基准 | 相同或更好 | 跳过更多行 |
| **内存占用** | 基准 | 相同 | 无明显变化 |

---

## 🧪 测试场景

### 1. 缓慢向下滚动

**测试步骤**:
1. 慢慢向下滚动
2. 观察行的高度变化

**预期结果**:
- ✅ 所有行保持完整高度
- ✅ 行自然地滑出可视区域
- ✅ 没有半截行

### 2. 缓慢向上滚动

**测试步骤**:
1. 慢慢向上滚动
2. 观察行的显示

**预期结果**:
- ✅ 行完整地进入可视区域
- ✅ 没有半截行
- ✅ 视觉简洁

### 3. 快速滚动

**测试步骤**:
1. 快速滚动到底部
2. 快速滚动回顶部

**预期结果**:
- ✅ 滚动流畅
- ✅ 行始终保持完整
- ✅ 无闪烁或跳跃

---

## ✅ 优化总结

### 核心改进

1. **简化逻辑** - 移除复杂的裁剪计算
2. **完整显示** - 只渲染完全可见的行
3. **自然体验** - 行自然地出现/消失
4. **性能优化** - 减少不必要的渲染

### 相关优化

本次优化与之前的优化相配合：
- ✅ 高度压缩修复（行保持完整高度）
- ✅ 表头覆盖修复（表头区域保护）
- ✅ 边界滚动修复（到达边界无法继续）
- ✅ 行完整显示（本次优化）

---

## 🎓 经验总结

### 虚拟滚动的最佳实践

1. **KISS 原则** - Keep It Simple, Stupid
   - 简单的逻辑更可靠
   - 避免过度优化

2. **用户体验优先**
   - 完整的内容比部分内容更好
   - 自然的出现/消失比裁剪更好

3. **信任平台能力**
   - Canvas 的自动裁剪很高效
   - 不需要手动计算所有边界

### 避免的反模式

❌ **错误的裁剪逻辑**:
```typescript
// 复杂的边界计算和裁剪
if (isPartiallyVisible) {
  const visibleHeight = calculateVisibleHeight()
  actualHeight = visibleHeight  // ❌ 导致半截行
}
```

✅ **正确的完整渲染**:
```typescript
// 简单的完整可见检查
if (y < headerHeight) {
  return  // 不渲染部分行 ✅
}
actualHeight = cellHeight  // ✅ 保持完整
```

---

**优化完成时间**: 2026-02-10
**相关文件**:
- `packages/ctable/src/core/G2TableRenderer.ts`
- `packages/ctable/src/core/G2TableRendererV2.ts`
