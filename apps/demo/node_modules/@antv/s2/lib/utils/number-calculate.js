"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calcActionByType = exports.getDataCountByField = exports.getDataAvgByField = exports.getDataExtremumByField = exports.getDataSumByField = exports.canConvertToNumber = exports.isNotNumber = void 0;
const tslib_1 = require("tslib");
const decimal_js_1 = tslib_1.__importDefault(require("decimal.js"));
const interface_1 = require("../common/interface");
const cell_data_1 = require("../data-set/cell-data");
const isNotNumber = (value) => {
    if (typeof value === 'number') {
        return Number.isNaN(value);
    }
    if (!value) {
        return true;
    }
    if (typeof value === 'string') {
        return Number.isNaN(Number(value));
    }
    return true;
};
exports.isNotNumber = isNotNumber;
const canConvertToNumber = (a) => !(0, exports.isNotNumber)(a);
exports.canConvertToNumber = canConvertToNumber;
/**
 * 预处理原始数据为 Decimal 对象数组
 * 所有不能转为 number 的数据默认为 0
 * @param data 原始数据数组
 * @param field 值字段
 * @param filterIllegalValue 是否过滤非法值？过滤后，包装后的数据数组短于原始数组长度
 * @returns 经过 Decimal 包装后的值数组
 */
const processFieldValues = (data, field, filterIllegalValue = false) => {
    if (!(data === null || data === void 0 ? void 0 : data.length)) {
        return [];
    }
    return data.reduce((resultArr, item) => {
        const fieldValue = cell_data_1.CellData.getFieldValue(item, field);
        const notNumber = (0, exports.isNotNumber)(fieldValue);
        if (filterIllegalValue && notNumber) {
            // 过滤非法值
            return resultArr;
        }
        const val = notNumber ? 0 : fieldValue;
        resultArr.push(new decimal_js_1.default(val));
        return resultArr;
    }, []);
};
/**
 * 计算数据项的和
 * @param data 数据项
 * @param field 值字段
 * @returns 算术和
 */
const getDataSumByField = (data, field) => {
    const fieldValues = processFieldValues(data, field);
    if (!fieldValues.length) {
        return 0;
    }
    return decimal_js_1.default.sum(...fieldValues).toNumber();
};
exports.getDataSumByField = getDataSumByField;
/**
 * 计算数据项的极值
 * @param method 最大值(max)或最小值(min)
 * @param data 数据项
 * @param field 值字段
 * @returns 最值
 */
const getDataExtremumByField = (method, data, field) => {
    // 防止预处理时默认值 0 影响极值结果，处理时需过滤非法值
    const fieldValues = processFieldValues(data, field, true);
    if (!(fieldValues === null || fieldValues === void 0 ? void 0 : fieldValues.length)) {
        return;
    }
    return decimal_js_1.default[method](...fieldValues).toNumber();
};
exports.getDataExtremumByField = getDataExtremumByField;
/**
 * 计算数据项的平均值
 * @param data 数据项
 * @param field 值字段
 * @returns 算术平均值
 */
const getDataAvgByField = (data, field) => {
    const fieldValues = processFieldValues(data, field);
    if (!(fieldValues === null || fieldValues === void 0 ? void 0 : fieldValues.length)) {
        return 0;
    }
    return decimal_js_1.default.sum(...fieldValues)
        .dividedBy(fieldValues.length)
        .toNumber();
};
exports.getDataAvgByField = getDataAvgByField;
/**
 *
 * @param data
 */
const getDataCountByField = (data) => {
    return (data === null || data === void 0 ? void 0 : data.length) || 0;
};
exports.getDataCountByField = getDataCountByField;
/**
 * totals 计算方法集合
 */
exports.calcActionByType = {
    [interface_1.Aggregation.SUM]: exports.getDataSumByField,
    [interface_1.Aggregation.MIN]: (data, field) => (0, exports.getDataExtremumByField)('min', data, field),
    [interface_1.Aggregation.MAX]: (data, field) => (0, exports.getDataExtremumByField)('max', data, field),
    [interface_1.Aggregation.AVG]: exports.getDataAvgByField,
    [interface_1.Aggregation.COUNT]: exports.getDataCountByField,
};
//# sourceMappingURL=number-calculate.js.map