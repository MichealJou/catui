"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBrushHeaderCopyable = void 0;
const lodash_1 = require("lodash");
const common_1 = require("../../../common");
const method_1 = require("../method");
const common_2 = require("./common");
/**
 * 过滤出 intersection cell 中所有叶子节点的 cellMeta
 * @param interactedCells
 * @param maxLevel
 * @returns {CellMeta[]}
 */
function getLastLevelCells(interactedCells, maxLevel) {
    return (0, lodash_1.filter)(interactedCells, (cell) => {
        const meta = cell.getMeta();
        const isLastLevel = meta.level === maxLevel;
        const isLastTotal = meta.isTotals && (0, lodash_1.isEmpty)(meta.children);
        return isLastLevel || isLastTotal;
    });
}
/**
 * 获取表头圈选后的 header cells 值矩阵
 * @param lastLevelCells
 * @param maxLevel
 * @param allLevel
 * @param withFormat
 * @returns {SimpleData[][]}
 */
function getHeaderCellMatrix(lastLevelCells, maxLevel, allLevel, withFormat) {
    return (0, lodash_1.map)(lastLevelCells, (cell) => {
        var _a;
        const node = cell.getMeta();
        if (withFormat) {
            const formatNames = (0, common_2.getNodeFormatData)(node);
            const minLevel = (_a = (0, lodash_1.min)(Array.from(allLevel))) !== null && _a !== void 0 ? _a : 0;
            return formatNames.slice(minLevel, maxLevel + 1);
        }
        // 保持原有的不格式化逻辑 (仅使用原始值)
        const { id, value, isTotals, level, spreadsheet } = node;
        let cellId = id;
        // 为总计小计补齐高度
        if (isTotals && level !== maxLevel) {
            cellId = id + common_1.NODE_ID_SEPARATOR + (0, lodash_1.repeat)(value, maxLevel - level);
        }
        return (0, method_1.getHeaderMeasureFieldNames)((0, method_1.getHeaderList)(cellId, allLevel.size), spreadsheet, false);
    });
}
/**
 * 获取表头圈选后的 header cells 值矩阵
 * @param {RowCell[] | ColCell[]} interactedCells
 * @return {CopyableList}
 */
function getBrushHeaderCopyable(interactedCells) {
    var _a, _b, _c, _d;
    // 获取圈选的层级有哪些
    const allLevels = (0, method_1.getAllLevels)(interactedCells);
    const maxLevel = (_a = (0, lodash_1.max)(Array.from(allLevels))) !== null && _a !== void 0 ? _a : 0;
    // 获取最后一层的 cell
    const lastLevelCells = getLastLevelCells(interactedCells, maxLevel);
    // 拼接选中行列头的内容矩阵
    const isCol = interactedCells[0].cellType === common_1.CellType.COL_CELL;
    const { spreadsheet } = interactedCells[0].getMeta();
    // 1. 从配置中读取 withFormat，这是让组件响应配置的第一步
    const withFormat = (_d = (_c = (_b = spreadsheet.options.interaction) === null || _b === void 0 ? void 0 : _b.copy) === null || _c === void 0 ? void 0 : _c.withFormat) !== null && _d !== void 0 ? _d : false;
    const headerCellMatrix = getHeaderCellMatrix(lastLevelCells, maxLevel, allLevels, withFormat);
    // 如果是列头，需要转置
    const cellMatrix = isCol ? (0, lodash_1.zip)(...headerCellMatrix) : headerCellMatrix;
    return [
        (0, common_2.matrixPlainTextTransformer)(cellMatrix),
        (0, common_2.matrixHtmlTransformer)(cellMatrix),
    ];
}
exports.getBrushHeaderCopyable = getBrushHeaderCopyable;
//# sourceMappingURL=pivot-header-copy.js.map