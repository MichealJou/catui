"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.strategyCopy = void 0;
const lodash_1 = require("lodash");
const common_1 = require("../../common");
const text_1 = require("../../text");
const method_1 = require("../method");
const common_2 = require("./common");
const pivot_data_cell_copy_1 = require("./pivot-data-cell-copy");
/**
 * Process the multi-measure with single-lines
 */
const processObjectValueInRow = (data, isFormat = false) => {
    var _a;
    if (!isFormat) {
        return (_a = (0, lodash_1.get)(data, ['originalValues', 0])) !== null && _a !== void 0 ? _a : (0, lodash_1.get)(data, ['values', 0]);
    }
    return (0, lodash_1.get)(data, ['values', 0]);
};
const getHeaderLabel = (val) => {
    const label = (0, common_1.safeJsonParse)(val);
    if ((0, lodash_1.isArray)(label)) {
        return label;
    }
    return val;
};
class StrategyCopyData extends pivot_data_cell_copy_1.PivotDataCellCopy {
    constructor(props) {
        super(props);
        this.getPlaceholder = (viewMeta, leafNode) => {
            const label = getHeaderLabel(leafNode.value);
            const labelLength = (0, lodash_1.isArray)(label) ? label.length : 1;
            const { placeholder } = this.spreadsheet.options;
            const placeholderStr = (0, text_1.getEmptyPlaceholder)(viewMeta, placeholder);
            return Array(labelLength).fill(placeholderStr);
        };
        /* Process the data when the value position is on the rows. */
        this.processValueInRow = (viewMeta, placeholder) => {
            var _a, _b;
            let tempCellValues = [];
            const defaultResult = placeholder !== null && placeholder !== void 0 ? placeholder : [''];
            if (!viewMeta) {
                return defaultResult;
            }
            const { fieldValue, valueField, data } = viewMeta;
            if ((0, lodash_1.isObject)(fieldValue)) {
                tempCellValues = processObjectValueInRow(fieldValue, this.config.formatHeader);
                return tempCellValues !== null && tempCellValues !== void 0 ? tempCellValues : placeholder;
            }
            // 如果本身格子的数据是 null， 但是一个格子又需要绘制多个指标时，需要使用placeholder填充
            if ((0, lodash_1.isNil)(fieldValue) && placeholder.length > 1) {
                return defaultResult;
            }
            // The main measure.
            if (!this.config.formatHeader) {
                tempCellValues.push((_a = fieldValue) !== null && _a !== void 0 ? _a : '');
            }
            else {
                const mainFormatter = this.spreadsheet.dataSet.getFieldFormatter(valueField);
                const tempCellValue = (_b = mainFormatter(fieldValue, data)) !== null && _b !== void 0 ? _b : '';
                tempCellValues.push(tempCellValue);
            }
            return tempCellValues !== null && tempCellValues !== void 0 ? tempCellValues : placeholder;
        };
        this.getCornerMatrix = (rowMatrix) => {
            return this.getCustomRowCornerMatrix(rowMatrix);
        };
        this.getDataMatrixByHeaderNode = () => {
            return (0, lodash_1.map)(this.leafRowNodes, (rowNode) => {
                // 获取每行的数据，如果无法获取到数据则使用 placeholder 填充
                const rowVal = this.leafColNodes.map((colNode) => {
                    var _a, _b;
                    const viewMeta = (_b = (_a = this.spreadsheet.facet).getCellMeta) === null || _b === void 0 ? void 0 : _b.call(_a, rowNode.rowIndex, colNode.colIndex);
                    const placeholder = this.getPlaceholder(viewMeta, colNode);
                    return this.processValueInRow(viewMeta, placeholder);
                });
                // 因为每个格子可能有多个指标时，则以数组展示。对于行头来说，需要将每个格子的展示拍平
                return (0, lodash_1.flatten)(rowVal);
            });
        };
        this.getPivotAllCopyData = () => {
            const rowMatrix = this.getRowMatrix();
            const colMatrix = this.getColMatrix();
            const cornerMatrix = this.getCornerMatrix(rowMatrix);
            const dataMatrix = this.getDataMatrixByHeaderNode();
            return this.matrixTransformer((0, common_2.assembleMatrix)({
                colMatrix,
                dataMatrix,
                rowMatrix,
                cornerMatrix,
            }), 
            // https://github.com/antvis/S2/issues/2701
            this.config.separator);
        };
    }
    // 趋势表都需要列头为"字符串数组类型"的 value, e.g.: "["数值","环比","同比"]"
    getColMatrix() {
        const result = [];
        (0, lodash_1.forEach)(this.leafColNodes, (node) => {
            const colList = this.config.formatHeader
                ? (0, common_2.getNodeFormatData)(node)
                : (0, method_1.getHeaderList)(node.id);
            // 倒着循环 colList
            let maxLen = 0;
            for (let i = colList.length - 1; i >= 0; i--) {
                const item = colList[i];
                let temp = [];
                // 如果是最后一个元素，且是 "["数值","环比","同比"]"，则需要转换
                if (item.startsWith('[') && item.endsWith(']')) {
                    temp = JSON.parse(item);
                    // 如果是 "["数值","环比","同比"]"，则转换为 "数值","环比","同比"
                    maxLen = temp.length > maxLen ? temp.length : maxLen;
                }
                else {
                    // 需要补全 "" 在后面，e.g.: "2022-09" => ["2022-09", "", ""]
                    temp = maxLen > 0 ? new Array(maxLen).fill('') : [];
                    temp[0] = item;
                }
                result[i] = result[i] ? result[i].concat(temp) : temp;
            }
        });
        return result;
    }
}
const strategyCopy = (params) => {
    const { sheetInstance, split, formatOptions } = params;
    const strategyCopyData = new StrategyCopyData({
        spreadsheet: sheetInstance,
        isExport: true,
        config: {
            separator: split,
            formatOptions,
        },
    });
    return strategyCopyData.getPivotAllCopyData()[0].content;
};
exports.strategyCopy = strategyCopy;
//# sourceMappingURL=strategy-copy.js.map