"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.asyncGetAllData = exports.asyncGetAllHtmlData = exports.asyncGetAllPlainData = exports.asyncProcessAllSelected = exports.getSelectedData = void 0;
const tslib_1 = require("tslib");
const lodash_1 = require("lodash");
const common_1 = require("../../../common");
const export_1 = require("../../../common/interface/export");
const method_1 = require("../method");
const utils_1 = require("../utils");
const pivot_data_cell_copy_1 = require("./pivot-data-cell-copy");
const pivot_header_copy_1 = require("./pivot-header-copy");
const table_copy_1 = require("./table-copy");
/**
 * 返回选中数据单元格生成的二维数组（ CellMeta[][]）
 * @param { CellMeta[] } cells
 */
const getSelectedCellsMeta = (cells) => {
    if (!(cells === null || cells === void 0 ? void 0 : cells.length)) {
        return [];
    }
    const [minCell, maxCell] = [
        { row: Infinity, col: Infinity },
        { row: 0, col: 0 },
    ];
    // get left-top cell and right-bottom cell position
    cells.forEach((e) => {
        const { rowIndex, colIndex } = e;
        minCell.col = Math.min(colIndex, minCell.col);
        minCell.row = Math.min(rowIndex, minCell.row);
        maxCell.col = Math.max(colIndex, maxCell.col);
        maxCell.row = Math.max(rowIndex, maxCell.row);
    });
    const [rowLen, colLen] = [
        maxCell.row - minCell.row + 1,
        maxCell.col - minCell.col + 1,
    ];
    const twoDimDataArray = new Array(rowLen)
        .fill('')
        .map(() => new Array(colLen).fill(''));
    cells.forEach((e) => {
        const { rowIndex, colIndex } = e;
        const [diffRow, diffCol] = [rowIndex - minCell.row, colIndex - minCell.col];
        twoDimDataArray[diffRow][diffCol] = e;
    });
    return twoDimDataArray;
};
const processSelectedByHeader = (spreadsheet, selectedRows) => {
    if (spreadsheet.isPivotMode()) {
        return (0, pivot_data_cell_copy_1.processSelectedPivotByHeader)(spreadsheet, selectedRows);
    }
    return (0, table_copy_1.processSelectedTableByHeader)(spreadsheet, selectedRows);
};
function getIsBrushHeader(interactedCells) {
    return (0, lodash_1.isEmpty)(interactedCells)
        ? false
        : (0, lodash_1.every)(interactedCells, (cell) => cell.cellType === common_1.CellType.ROW_CELL ||
            cell.cellType === common_1.CellType.COL_CELL);
}
function processSelectedByData(selectedCellsMeta, selectedColMetas, selectedRowMetas, spreadsheet) {
    if (spreadsheet.isPivotMode()) {
        return (0, pivot_data_cell_copy_1.processSelectedPivotByDataCell)({
            spreadsheet,
            selectedCells: selectedCellsMeta,
            headerSelectedCells: (0, lodash_1.concat)(selectedColMetas, selectedRowMetas),
        });
    }
    return (0, table_copy_1.processSelectedTableByDataCell)({
        spreadsheet,
        selectedCells: selectedCellsMeta,
        headerSelectedCells: selectedColMetas,
    });
}
function getDataCellCopyable(spreadsheet, cells) {
    let data;
    const selectedCols = (0, method_1.getSelectedCols)(cells);
    const selectedRows = (0, method_1.getSelectedRows)(cells);
    if (spreadsheet.interaction.getCurrentStateName() ===
        common_1.InteractionStateName.ALL_SELECTED) {
        data = processSelectedByHeader(spreadsheet, []);
    }
    else if (selectedCols.length) {
        // 选中某列
        data = processSelectedByHeader(spreadsheet, selectedCols);
    }
    else if (selectedRows.length) {
        // 选中某行
        data = processSelectedByHeader(spreadsheet, selectedRows);
    }
    else {
        if (!cells.length) {
            return [
                {
                    type: export_1.CopyMIMEType.PLAIN,
                    content: '',
                },
                {
                    type: export_1.CopyMIMEType.HTML,
                    content: '',
                },
            ];
        }
        // normal selected
        const selectedCellsMeta = getSelectedCellsMeta(cells);
        const selectedColMetas = selectedCellsMeta[0].map((cellMeta) => {
            var _a;
            return Object.assign(Object.assign({}, cellMeta), { id: (cellMeta === null || cellMeta === void 0 ? void 0 : cellMeta.colId) ||
                    (0, lodash_1.last)((_a = cellMeta === null || cellMeta === void 0 ? void 0 : cellMeta.id) === null || _a === void 0 ? void 0 : _a.split(common_1.DATA_CELL_ID_SEPARATOR)) ||
                    '', type: common_1.CellType.COL_CELL });
        });
        const selectedRowMetas = selectedCellsMeta.map((cellMeta) => {
            var _a, _b, _c;
            return Object.assign(Object.assign({}, cellMeta[0]), { id: ((_a = cellMeta[0]) === null || _a === void 0 ? void 0 : _a.rowId) ||
                    (0, lodash_1.first)((_c = (_b = cellMeta[0]) === null || _b === void 0 ? void 0 : _b.id) === null || _c === void 0 ? void 0 : _c.split(common_1.DATA_CELL_ID_SEPARATOR)) ||
                    '', type: common_1.CellType.ROW_CELL });
        });
        data = processSelectedByData(selectedCellsMeta, selectedColMetas, selectedRowMetas, spreadsheet);
    }
    return data;
}
// 刷选复制使用
const getSelectedData = (spreadsheet) => {
    var _a;
    const interaction = spreadsheet.interaction;
    const cells = interaction.getState().cells || [];
    // 通过判断当前存在交互的单元格，来区分圈选行/列头 还是 点选行/列头
    const interactedCells = (_a = interaction.getInteractedCells()) !== null && _a !== void 0 ? _a : [];
    const isBrushHeader = getIsBrushHeader(interactedCells);
    // 行列头圈选复制 和 单元格复制不同
    const data = isBrushHeader
        ? (0, pivot_header_copy_1.getBrushHeaderCopyable)(interactedCells)
        : getDataCellCopyable(spreadsheet, cells);
    if (data) {
        (0, utils_1.copyToClipboard)(data);
    }
    return data;
};
exports.getSelectedData = getSelectedData;
// 异步全量导出
const asyncProcessAllSelected = (params) => {
    const { sheetInstance } = params;
    const check = sheetInstance.enableAsyncExport();
    if (check instanceof Error) {
        // eslint-disable-next-line no-console
        console.warn(check);
        throw check;
    }
    if (sheetInstance.isPivotMode()) {
        return (0, pivot_data_cell_copy_1.asyncProcessSelectedAllPivot)(params);
    }
    return (0, table_copy_1.asyncProcessSelectedAllTable)(params);
};
exports.asyncProcessAllSelected = asyncProcessAllSelected;
/**
 * 异步获取文本数据 (text/plain)
 * @example
    const data = await asyncGetAllPlainData({
      sheetInstance: s2,
      split: '\t',
      formatOptions: true,
    });
 */
const asyncGetAllPlainData = (params) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const result = yield (0, exports.asyncProcessAllSelected)(params);
    return result[0].content;
});
exports.asyncGetAllPlainData = asyncGetAllPlainData;
/**
 * 异步获取富文本数据 (text/html)
 * @example
    const data = await asyncGetAllHtmlData({
      sheetInstance: s2,
      split: '\t',
      formatOptions: true,
    });
 */
const asyncGetAllHtmlData = (params) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const result = yield (0, exports.asyncProcessAllSelected)(params);
    return result[1].content;
});
exports.asyncGetAllHtmlData = asyncGetAllHtmlData;
/**
 * 异步获取数据
 * - 文本 (text/plain)
 * - 富文本 (text/html)
 * @example
    const data = await asyncGetAllData({
      sheetInstance: s2,
      split: '\t',
      formatOptions: true,
    });
 */
const asyncGetAllData = (params) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const result = yield (0, exports.asyncProcessAllSelected)(params);
    return result;
});
exports.asyncGetAllData = asyncGetAllData;
//# sourceMappingURL=core.js.map