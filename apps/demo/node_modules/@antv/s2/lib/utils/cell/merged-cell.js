"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRightAndBottomCells = exports.getPolygonPoints = exports.getNextEdge = exports.unique = exports.getRectangleEdges = void 0;
const lodash_1 = require("lodash");
/**
 *  according to the coordinates of the starting point of the rectangle,
 * return the four sides of the rectangle in a clockwise direction.
 * [TopLeft] --- [TopRight]
 *    |               |
 * [BottomLeft] -[BottomRight]
 * @param x
 * @param y
 * @param width
 * @param height
 */
const getRectangleEdges = (x, y, width, height) => {
    const topLeft = [x, y];
    const topRight = [x + width, y];
    const bottomRight = [x + width, y + height];
    const bottomLeft = [x, y + height];
    return [
        [topLeft, topRight],
        [topRight, bottomRight],
        [bottomRight, bottomLeft],
        [bottomLeft, topLeft],
    ];
};
exports.getRectangleEdges = getRectangleEdges;
/**
 * return the edges without overlapping edges
 * @param edges the collection of edges
 */
const unique = (edges) => {
    const result = [];
    (0, lodash_1.forEach)(edges, (edge) => {
        const reverseEdge = [edge[1], edge[0]];
        if (!JSON.stringify(edges).includes(JSON.stringify(reverseEdge))) {
            result.push(edge);
        }
    });
    return result;
};
exports.unique = unique;
/**
 * return the edge according to the  coordinate of current edge
 * eg: curEdge: [[0,0], [100,0]] then the next edge: [[100, 0 ], [100, 100]]
 * @param curEdge the  coordinate of current edge
 * @param edges the collection of edges
 */
const getNextEdge = (curEdge, edges) => (0, lodash_1.find)(edges, (edge) => (0, lodash_1.isEqual)(edge[0], curEdge[1]));
exports.getNextEdge = getNextEdge;
/**
 * return all the points of the polygon
 * @param cells the collection of information of cells which needed be merged
 */
const getPolygonPoints = (cells) => {
    let allEdges = [];
    cells.forEach((cell) => {
        const meta = cell.getMeta();
        const { x, y, width, height } = meta;
        allEdges = allEdges.concat((0, exports.getRectangleEdges)(x, y, width, height));
    });
    allEdges = (0, exports.unique)(allEdges);
    let allPoints = [];
    const startEdge = allEdges[0];
    let curEdge = startEdge;
    let nextEdge = [];
    while (!(0, lodash_1.isEqual)(startEdge, nextEdge)) {
        allPoints = allPoints.concat(curEdge);
        nextEdge = (0, exports.getNextEdge)(curEdge, allEdges);
        curEdge = nextEdge;
    }
    return allPoints;
};
exports.getPolygonPoints = getPolygonPoints;
const getRightAndBottomCells = (cells) => {
    const right = [];
    const bottom = [];
    const bottomRightCornerCell = [];
    cells.forEach((cell) => {
        const [row, col] = cell.position || [];
        if (!(0, lodash_1.find)(cells, (temp) => { var _a, _b; return ((_a = temp.position) === null || _a === void 0 ? void 0 : _a[0]) === row + 1 && ((_b = temp.position) === null || _b === void 0 ? void 0 : _b[1]) === col; })) {
            bottom.push(cell);
        }
        if (!(0, lodash_1.find)(cells, (temp) => { var _a, _b; return ((_a = temp.position) === null || _a === void 0 ? void 0 : _a[1]) === col + 1 && ((_b = temp.position) === null || _b === void 0 ? void 0 : _b[0]) === row; })) {
            right.push(cell);
        }
    });
    // 在绘制了 right border 后，如果它上面的 cell 也是 merge cell 中的，且无需绘制 right 时，需要单独为其位置 bottomRight corner 的 border，反正连线会断
    right.forEach((cell) => {
        const [row, col] = cell.position || [];
        const top = (0, lodash_1.find)(cells, (temp) => { var _a, _b; return ((_a = temp.position) === null || _a === void 0 ? void 0 : _a[0]) === row - 1 && ((_b = temp.position) === null || _b === void 0 ? void 0 : _b[1]) === col; });
        if (top && !(0, lodash_1.includes)(right, top)) {
            bottomRightCornerCell.push(top);
        }
    });
    return {
        bottom,
        right,
        bottomRightCornerCell,
    };
};
exports.getRightAndBottomCells = getRightAndBottomCells;
//# sourceMappingURL=merged-cell.js.map