"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createOrUpdateRect = exports.batchSetStyle = exports.renderTreeIcon = exports.renderIcon = exports.updateShapeAttr = exports.renderLine = exports.renderText = exports.renderCircle = exports.renderPolyline = exports.renderPolygon = exports.renderRect = void 0;
/**
 * Utils to render all g supported shape
 * https://github.com/antvis/g
 */
const g_1 = require("@antv/g");
const lodash_1 = require("lodash");
const gui_icon_1 = require("../common/icons/gui-icon");
const CustomText_1 = require("../engine/CustomText");
function renderRect(group, style) {
    return group === null || group === void 0 ? void 0 : group.appendChild(new g_1.Rect({
        style,
    }));
}
exports.renderRect = renderRect;
function renderPolygon(group, style) {
    return group === null || group === void 0 ? void 0 : group.appendChild(new g_1.Polygon({ style }));
}
exports.renderPolygon = renderPolygon;
function renderPolyline(group, style) {
    return group === null || group === void 0 ? void 0 : group.appendChild(new g_1.Polyline({
        style,
    }));
}
exports.renderPolyline = renderPolyline;
function renderCircle(group, style) {
    return group === null || group === void 0 ? void 0 : group.appendChild(new g_1.Circle({
        style,
    }));
}
exports.renderCircle = renderCircle;
/**
 * @description 如果在单元格内绘制, 是使用 cell.renderTextShape(options)
 */
function renderText(options) {
    const { group, textShape, style, appendInfo } = options;
    if (textShape && group) {
        if (group.contains(textShape)) {
            group.removeChild(textShape);
        }
    }
    return group === null || group === void 0 ? void 0 : group.appendChild(new CustomText_1.CustomText({
        style: Object.assign({ 
            /**
             * 补充 g5.0 内部 measureText 时的必要参数（variant|fontStyle|lineWidth）
             * 否则创建完 Text 后，实例 getBBox 返回为全 0
             * @see https://github.com/antvis/GUI/blob/302ae68d93dbb5675f35fca37e8821d4427d495b/src/util/style.ts#L18-L29
             */
            fontVariant: 'normal', fontStyle: 'normal', lineWidth: 1 }, style),
    }, appendInfo || {}));
}
exports.renderText = renderText;
function renderLine(group, options) {
    return group === null || group === void 0 ? void 0 : group.appendChild(new g_1.Line({
        style: Object.assign({ zIndex: 100 }, options),
    }));
}
exports.renderLine = renderLine;
function updateShapeAttr(shapeGroup, styleName, styleValue) {
    if ((0, lodash_1.isEmpty)(shapeGroup)) {
        return;
    }
    const shapes = (0, lodash_1.isArray)(shapeGroup) ? shapeGroup : [shapeGroup];
    shapes.forEach((shape) => {
        var _a;
        // https://g-next.antv.vision/zh/docs/api/basic/display-object#%E8%8E%B7%E5%8F%96%E8%AE%BE%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%80%BC
        (_a = shape === null || shape === void 0 ? void 0 : shape.style) === null || _a === void 0 ? void 0 : _a.setProperty(styleName, styleValue);
    });
}
exports.updateShapeAttr = updateShapeAttr;
function renderIcon(group, iconCfg) {
    const iconShape = new gui_icon_1.GuiIcon(iconCfg);
    group === null || group === void 0 ? void 0 : group.appendChild(iconShape);
    return iconShape;
}
exports.renderIcon = renderIcon;
function renderTreeIcon(options) {
    const { group, iconCfg, isCollapsed, onClick } = options;
    const iconShape = renderIcon(group, Object.assign(Object.assign({}, iconCfg), { name: isCollapsed ? 'Plus' : 'Minus', cursor: 'pointer' }));
    if ((0, lodash_1.isFunction)(onClick)) {
        iconShape.addEventListener('click', onClick);
    }
    return iconShape;
}
exports.renderTreeIcon = renderTreeIcon;
function batchSetStyle(obj, style) {
    for (const styleKey in style) {
        obj.style[styleKey] = style[styleKey];
    }
}
exports.batchSetStyle = batchSetStyle;
function createOrUpdateRect(propertyPath, style) {
    // @ts-ignore
    const context = this;
    const obj = (0, lodash_1.get)(context, propertyPath);
    if (!obj) {
        (0, lodash_1.set)(context, propertyPath, new g_1.Rect({ style }));
    }
    else {
        batchSetStyle(obj, style);
    }
}
exports.createOrUpdateRect = createOrUpdateRect;
//# sourceMappingURL=g-renders.js.map