"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseNumberWithPrecision = exports.auto = void 0;
const lodash_1 = require("lodash");
const constant_1 = require("../common/constant");
const i18n_1 = require("../common/i18n");
const FORMATTERS = {
    en_US: ['KMBTP'.split(''), [1e3, 1e3, 1e3, 1e3, 1e3]],
    ru_RU: [
        ['тысяча', 'миллион', 'миллиард', 'триллион', 'квадриллион'],
        [1e3, 1e3, 1e3, 1e3, 1e3],
    ],
    zh_CN: [
        ['万', '亿'],
        [1e4, 1e4],
    ],
};
/**
 * 自动格式化
 * 规则
 *  1，小于1w，使用逗号分割，例如 3,459
 *  2，大于1w，使用语义化，例如 3.2万，3.4亿 2,234万
 * @param v
 * @param fixed
 * @param formatter
 */
const auto = (v, fixed = 2, formatter = FORMATTERS[(0, i18n_1.getLang)()] || FORMATTERS.zh_CN) => {
    if (typeof v !== 'number' || (0, lodash_1.isNaN)(v)) {
        return '';
    }
    // let n = Math.abs(v); // abs什么鬼。
    let n = v;
    // 语义化
    const [texts, powers] = formatter;
    let loop = 0;
    let power;
    let running = true;
    while (running) {
        power = powers[loop];
        if (n >= power && loop < texts.length) {
            n /= power;
        }
        else {
            running = false;
        }
        loop += 1;
    }
    /*
     * parseFloat 解决 toFixed 出现很多 0 结尾。
     * 举例：123.toFixed(2) = '123.00'，需要返回 '123'
     */
    n = parseFloat(n.toFixed(fixed));
    // 千分位
    const output = n >= 1000 ? n.toLocaleString('en') : `${n}`;
    // 加上最后的单位
    return loop === 0 ? output : `${output} ${texts[loop - 1]}`;
};
exports.auto = auto;
/*
 * 简单处理小数精度误差，保持和Spreadsheet统一逻辑
 * 技术细节：https://juejin.im/post/5ce373d651882532e409ea96
 */
const parseNumberWithPrecision = (value) => Number.parseFloat(((0, lodash_1.toNumber)(value) || 0).toPrecision(constant_1.PRECISION));
exports.parseNumberWithPrecision = parseNumberWithPrecision;
//# sourceMappingURL=formatter.js.map