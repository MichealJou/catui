"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateMergedCells = exports.differenceTempMergedCells = exports.mergedCellConvertTempMergedCells = exports.mergeTempMergedCell = exports.unmergeCell = exports.removeUnmergedCellsInfo = exports.mergeCell = exports.getMergedCellInstance = exports.getActiveCellsInfo = exports.getTempMergedCell = exports.getVisibleInfo = exports.getInvisibleInfo = void 0;
const lodash_1 = require("lodash");
const merged_cell_1 = require("../../cell/merged-cell");
const constant_1 = require("../../common/constant");
/**
 * get cells on the outside of visible area through mergeCellInfo
 * @param invisibleCellInfo
 * @param sheet
 */
const getInvisibleInfo = (invisibleCellInfo, sheet) => {
    const cells = [];
    let viewMeta;
    (0, lodash_1.forEach)(invisibleCellInfo, (cellInfo) => {
        var _a, _b;
        const meta = (_a = sheet === null || sheet === void 0 ? void 0 : sheet.facet) === null || _a === void 0 ? void 0 : _a.getCellMeta(cellInfo.rowIndex, cellInfo.colIndex);
        const cell = (_b = sheet === null || sheet === void 0 ? void 0 : sheet.facet) === null || _b === void 0 ? void 0 : _b.createDataCell(meta);
        if (cell) {
            cells.push(cell);
            viewMeta = (cellInfo === null || cellInfo === void 0 ? void 0 : cellInfo.showText) ? meta : viewMeta;
        }
    });
    return { cells, cellsMeta: viewMeta };
};
exports.getInvisibleInfo = getInvisibleInfo;
/**
 * get { cells, invisibleCellInfo, cellsMeta } in the inside of visible area through mergeCellInfo
 * @param cellsInfos
 * @param allVisibleCells
 * @returns { cells, invisibleCellInfo, cellsMeta }
 */
const getVisibleInfo = (cellsInfos, allVisibleCells) => {
    const cells = [];
    const invisibleCellInfo = [];
    let cellsMeta;
    (0, lodash_1.forEach)(cellsInfos, (cellInfo) => {
        const findCell = (0, lodash_1.find)(allVisibleCells, (cell) => {
            var _a;
            const meta = (_a = cell === null || cell === void 0 ? void 0 : cell.getMeta) === null || _a === void 0 ? void 0 : _a.call(cell);
            if ((meta === null || meta === void 0 ? void 0 : meta.colIndex) === (cellInfo === null || cellInfo === void 0 ? void 0 : cellInfo.colIndex) &&
                (meta === null || meta === void 0 ? void 0 : meta.rowIndex) === (cellInfo === null || cellInfo === void 0 ? void 0 : cellInfo.rowIndex)) {
                return cell;
            }
        });
        if (findCell) {
            cells.push(findCell);
            cellsMeta = (cellInfo === null || cellInfo === void 0 ? void 0 : cellInfo.showText)
                ? findCell === null || findCell === void 0 ? void 0 : findCell.getMeta()
                : cellsMeta;
        }
        else {
            invisibleCellInfo.push(cellInfo);
        }
    });
    return { cells, invisibleCellInfo, cellsMeta };
};
exports.getVisibleInfo = getVisibleInfo;
/**
 * get the data cell and meta that make up the mergedCell
 * @param cellsInfos
 * @param allVisibleCells
 * @param sheet
 */
const getTempMergedCell = (allVisibleCells, sheet, cellsInfos = []) => {
    var _a;
    const { cellsMeta, cells, invisibleCellInfo } = (0, exports.getVisibleInfo)(cellsInfos, allVisibleCells);
    let viewMeta = cellsMeta;
    let mergedAllCells = cells;
    // some cells are invisible and some cells are visible
    const isPartiallyVisible = (invisibleCellInfo === null || invisibleCellInfo === void 0 ? void 0 : invisibleCellInfo.length) > 0 &&
        invisibleCellInfo.length < cellsInfos.length;
    // 当 MergedCell 只有部分在可视区域时，在此获取 MergedCell 不在可视区域内的 cells
    if (isPartiallyVisible) {
        const { cells: invisibleCells, cellsMeta: invisibleMeta } = (0, exports.getInvisibleInfo)(invisibleCellInfo, sheet);
        viewMeta = viewMeta || invisibleMeta;
        mergedAllCells = cells.concat(invisibleCells);
    }
    if (!(0, lodash_1.isEmpty)(cells) && !viewMeta) {
        // 如果没有指定合并后的文本绘制的位置，默认画在选择的第一个单元格内
        viewMeta = (_a = mergedAllCells[0]) === null || _a === void 0 ? void 0 : _a.getMeta();
    }
    return {
        cells: mergedAllCells,
        viewMeta: viewMeta,
    };
};
exports.getTempMergedCell = getTempMergedCell;
/**
 * get the active cells' info as the default info of merged cells
 * @param sheet
 */
const getActiveCellsInfo = (sheet) => {
    const { interaction } = sheet;
    const cells = interaction.getActiveCells();
    const mergedCellsInfo = [];
    (0, lodash_1.forEach)(cells, (cell, index) => {
        const meta = cell.getMeta();
        // 在合并单元格中，第一个单元格被标标记为展示数据。
        const showText = index === 0 ? { showText: true } : {};
        mergedCellsInfo.push(Object.assign(Object.assign({}, showText), { colIndex: meta === null || meta === void 0 ? void 0 : meta.colIndex, rowIndex: meta === null || meta === void 0 ? void 0 : meta.rowIndex }));
    });
    return mergedCellsInfo;
};
exports.getActiveCellsInfo = getActiveCellsInfo;
/**
 * 创建 merged cell 实例
 * @param spreadsheet 表格实例
 * @param cells 待合并的单元格
 * @param meta 元信息
 * @returns
 */
const getMergedCellInstance = (spreadsheet, cells, meta) => {
    var _a;
    if ((_a = spreadsheet.options) === null || _a === void 0 ? void 0 : _a.mergedCell) {
        return spreadsheet.options.mergedCell(spreadsheet, cells, meta);
    }
    return new merged_cell_1.MergedCell(spreadsheet, cells, meta);
};
exports.getMergedCellInstance = getMergedCellInstance;
/**
 * draw the background of the merged cell
 * @param sheet the base sheet instance
 * @param cellsInfo
 * @param hideData
 */
const mergeCell = (sheet, cellsInfo, hideData) => {
    var _a;
    const mergeCellInfo = cellsInfo || (0, exports.getActiveCellsInfo)(sheet);
    if ((mergeCellInfo === null || mergeCellInfo === void 0 ? void 0 : mergeCellInfo.length) <= 1) {
        // eslint-disable-next-line no-console
        console.error('[mergeCell]: The merged cells must be more than one!');
        return;
    }
    const allVisibleCells = sheet.facet.getDataCells();
    const { cells, viewMeta } = (0, exports.getTempMergedCell)(allVisibleCells, sheet, mergeCellInfo);
    if (!(0, lodash_1.isEmpty)(cells)) {
        const mergedCellInfoList = ((_a = sheet.options) === null || _a === void 0 ? void 0 : _a.mergedCellsInfo) || [];
        mergedCellInfoList.push(mergeCellInfo);
        sheet.setOptions({
            mergedCellsInfo: mergedCellInfoList,
        });
        const meta = hideData ? undefined : viewMeta;
        sheet.facet.panelScrollGroup.addMergeCell((0, exports.getMergedCellInstance)(sheet, cells, meta));
    }
};
exports.mergeCell = mergeCell;
/**
 * remove unmergedCells Info, return new mergedCell info
 * @param removeMergedCell
 * @param mergedCellsInfo
 */
const removeUnmergedCellsInfo = (removeMergedCell, mergedCellsInfo) => {
    const removeCellInfo = (0, lodash_1.map)(removeMergedCell.cells, (cell) => {
        return {
            colIndex: cell.getMeta().colIndex,
            rowIndex: cell.getMeta().rowIndex,
        };
    });
    return (0, lodash_1.filter)(mergedCellsInfo, (mergedCellInfo) => {
        const newMergedCellInfo = mergedCellInfo.map((info) => {
            if (info.showText) {
                return {
                    colIndex: info.colIndex,
                    rowIndex: info.rowIndex,
                };
            }
            return info;
        });
        return !(0, lodash_1.isEqual)(newMergedCellInfo, removeCellInfo);
    });
};
exports.removeUnmergedCellsInfo = removeUnmergedCellsInfo;
/**
 * unmerge MergedCell
 * @param removedCell
 * @param sheet
 */
const unmergeCell = (sheet, removedCell) => {
    var _a, _b, _c;
    if (!removedCell || removedCell.cellType !== constant_1.CellType.MERGED_CELL) {
        // eslint-disable-next-line no-console
        console.error(`[unmergeCell]: The ${removedCell} is not a MergedCell`);
        return;
    }
    const newMergedCellsInfo = (0, exports.removeUnmergedCellsInfo)(removedCell, ((_a = sheet.options) === null || _a === void 0 ? void 0 : _a.mergedCellsInfo) || []);
    if ((newMergedCellsInfo === null || newMergedCellsInfo === void 0 ? void 0 : newMergedCellsInfo.length) !== ((_c = (_b = sheet.options) === null || _b === void 0 ? void 0 : _b.mergedCellsInfo) === null || _c === void 0 ? void 0 : _c.length)) {
        sheet.setOptions({
            mergedCellsInfo: newMergedCellsInfo,
        });
        removedCell.remove();
    }
};
exports.unmergeCell = unmergeCell;
/**
 * 合并 TempMergedCell, 通过 cell.viewMeta.id 判断 TempMergedCell 是否是同一个。
 * @param TempMergedCells
 * @param otherTempMergedCells
 */
const mergeTempMergedCell = (TempMergedCells, otherTempMergedCells) => {
    const mergedTempMergedCells = {};
    [...TempMergedCells, ...otherTempMergedCells].forEach((cell) => {
        mergedTempMergedCells[cell.viewMeta.id] = cell;
    });
    return Object.values(mergedTempMergedCells);
};
exports.mergeTempMergedCell = mergeTempMergedCell;
/**
 * 将 MergedCell 转换成 TempMergedCell
 * @param oldMergedCells
 * @constructor
 */
const mergedCellConvertTempMergedCells = (oldMergedCells) => (0, lodash_1.map)(oldMergedCells, (mergedCell) => {
    return {
        cells: mergedCell.cells,
        viewMeta: mergedCell.getMeta(),
    };
});
exports.mergedCellConvertTempMergedCells = mergedCellConvertTempMergedCells;
/**
 * 对比两个TempMergedCell，返回 mainTempMergedCells 中存在的，但是 otherTempMergedCells 中不存在的的 TempMergedCell
 * @param mainTempMergedCells
 * @param compareTempMergedCells
 */
const differenceTempMergedCells = (mainTempMergedCells, compareTempMergedCells) => (0, lodash_1.differenceWith)(mainTempMergedCells, compareTempMergedCells, (main, compare) => (0, lodash_1.isEqual)(main.viewMeta.id, compare.viewMeta.id));
exports.differenceTempMergedCells = differenceTempMergedCells;
/**
 * update the mergedCell
 * @param sheet the base sheet instance
 */
const updateMergedCells = (sheet, mergedCellsGroup) => {
    var _a;
    const mergedCellsInfo = (_a = sheet.options) === null || _a === void 0 ? void 0 : _a.mergedCellsInfo;
    if ((0, lodash_1.isEmpty)(mergedCellsInfo)) {
        return;
    }
    // 可见区域的所有cells
    const allCells = sheet.facet.getDataCells();
    if ((0, lodash_1.isEmpty)(allCells)) {
        return;
    }
    // allVisibleTempMergedCells 所有可视区域的 mergedCell
    const allVisibleTempMergedCells = [];
    mergedCellsInfo.forEach((cellsInfo) => {
        const tempMergedCell = (0, exports.getTempMergedCell)(allCells, sheet, cellsInfo);
        if (tempMergedCell.cells.length > 0) {
            allVisibleTempMergedCells.push(tempMergedCell);
        }
    });
    // 获取 oldTempMergedCells 便用后续进行 diff 操作
    const oldMergedCells = mergedCellsGroup.children;
    const oldTempMergedCells = (0, exports.mergedCellConvertTempMergedCells)(oldMergedCells);
    // compare oldTempMergedCells and allTempMergedCells, find remove MergedCells and add MergedCells
    const removeTempMergedCells = (0, exports.differenceTempMergedCells)(oldTempMergedCells, allVisibleTempMergedCells);
    const addTempMergedCells = (0, exports.differenceTempMergedCells)(allVisibleTempMergedCells, oldTempMergedCells);
    // remove old MergedCells
    (0, lodash_1.forEach)(removeTempMergedCells, (tempMergedCell) => {
        const oldMergedCell = (0, lodash_1.find)(oldMergedCells, (mergedCell) => (0, lodash_1.isEqual)(mergedCell.getMeta().id, tempMergedCell.viewMeta.id));
        oldMergedCell === null || oldMergedCell === void 0 ? void 0 : oldMergedCell.remove();
    });
    // add new MergedCells
    (0, lodash_1.forEach)(addTempMergedCells, ({ cells, viewMeta }) => {
        mergedCellsGroup.appendChild((0, exports.getMergedCellInstance)(sheet, cells, viewMeta));
    });
};
exports.updateMergedCells = updateMergedCells;
//# sourceMappingURL=merge-cell.js.map