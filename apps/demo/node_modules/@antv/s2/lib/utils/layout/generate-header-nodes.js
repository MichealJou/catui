"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateHeaderNodes = void 0;
const constant_1 = require("../../common/constant");
const i18n_1 = require("../../common/i18n");
const layout_hooks_1 = require("../../facet/layout/layout-hooks");
const node_1 = require("../../facet/layout/node");
const total_class_1 = require("../../facet/layout/total-class");
const total_measure_1 = require("../../facet/layout/total-measure");
const generate_id_1 = require("../../utils/layout/generate-id");
const whether_leaf_by_level_1 = require("./whether-leaf-by-level");
// eslint-disable-next-line max-lines-per-function
const generateHeaderNodes = (params) => {
    var _a, _b;
    const { currentField, fields, fieldValues, hierarchy, parentNode, level, query, addMeasureInTotalQuery, addTotalMeasureInTotal, spreadsheet, handler, } = params;
    const isTableMode = spreadsheet.isTableMode();
    for (const [index, originalFieldValue] of fieldValues.entries()) {
        const fieldValue = (0, generate_id_1.resolveNillString)(originalFieldValue);
        const isTotals = total_class_1.TotalClass.isTotalClassInstance(fieldValue);
        const isTotalMeasure = total_measure_1.TotalMeasure.isTotalMeasureInstance(fieldValue);
        let value;
        let nodeQuery;
        let isLeaf = false;
        let isGrandTotals = false;
        let isSubTotals = false;
        let isTotalRoot = false;
        let adjustedField = currentField;
        if (isTotals) {
            isGrandTotals = fieldValue.isGrandTotals;
            isSubTotals = fieldValue.isSubTotals;
            isTotalRoot = fieldValue.isTotalRoot;
            value = (0, i18n_1.i18n)(fieldValue.label);
            if (isTotalRoot) {
                nodeQuery = Object.assign({}, query);
            }
            else {
                // root[&]四川[&]总计 => {province: '四川'}
                nodeQuery = Object.assign(Object.assign({}, query), { [currentField]: value });
            }
            if (addMeasureInTotalQuery) {
                // root[&]四川[&]总计 => {province: '四川', EXTRA_FIELD: 'price'}
                nodeQuery[constant_1.EXTRA_FIELD] = (_a = spreadsheet === null || spreadsheet === void 0 ? void 0 : spreadsheet.dataSet) === null || _a === void 0 ? void 0 : _a.fields.values[0];
            }
            isLeaf = (0, whether_leaf_by_level_1.whetherLeafByLevel)({ spreadsheet, level, fields });
        }
        else if (isTotalMeasure) {
            value = (0, i18n_1.i18n)(fieldValue.label);
            // root[&]四川[&]总计[&]price => {province: '四川',EXTRA_FIELD: 'price' }
            nodeQuery = Object.assign(Object.assign({}, query), { [constant_1.EXTRA_FIELD]: value });
            adjustedField = constant_1.EXTRA_FIELD;
            isGrandTotals = parentNode.isGrandTotals;
            isSubTotals = parentNode.isSubTotals;
            isLeaf = (0, whether_leaf_by_level_1.whetherLeafByLevel)({ spreadsheet, level, fields });
        }
        else if (isTableMode) {
            value = fieldValue;
            adjustedField = fields[index];
            nodeQuery = Object.assign(Object.assign({}, query), { [adjustedField]: value });
            isLeaf = true;
        }
        else {
            value = fieldValue;
            // root[&]四川[&]成都 => {province: '四川', city: '成都' }
            // 子维度的维值为空时, 使用父级节点的 query, 避免查询不到数据
            nodeQuery =
                value === constant_1.EMPTY_FIELD_VALUE
                    ? Object.assign({}, query) : Object.assign(Object.assign({}, query), { [currentField]: value });
            isLeaf = (0, whether_leaf_by_level_1.whetherLeafByLevel)({ spreadsheet, level, fields });
        }
        // 明细表使用 field 生成 id, 保证唯一性, 避免同名的情况
        const displayField = isTableMode ? adjustedField : value;
        const nodeId = (0, generate_id_1.generateId)(parentNode.id, displayField);
        if (!nodeId) {
            return;
        }
        const isCollapsed = false;
        // create new header nodes
        const node = new node_1.Node({
            id: nodeId,
            value,
            level,
            field: adjustedField,
            parent: parentNode,
            isTotals: isTotals || isTotalMeasure,
            isGrandTotals,
            isSubTotals,
            isTotalMeasure,
            isCollapsed,
            isTotalRoot,
            hierarchy,
            query: nodeQuery,
            spreadsheet,
            isLeaf: isLeaf || isCollapsed,
        });
        const expandCurrentNode = (0, layout_hooks_1.layoutHierarchy)(spreadsheet, parentNode, node, hierarchy);
        // 如果当前是隐藏节点, 给其父节点挂载相应信息 (兄弟节点, 当前哪个子节点隐藏了), 这样在 facet 层可以直接使用, 不用每次都去遍历
        const hiddenColumnsInfo = (_b = spreadsheet === null || spreadsheet === void 0 ? void 0 : spreadsheet.facet) === null || _b === void 0 ? void 0 : _b.getHiddenColumnsInfo(node);
        // omit the the whole column or row of the grandTotal or subTotals
        if (level > hierarchy.maxLevel &&
            !isGrandTotals &&
            !parentNode.isGrandTotals &&
            !parentNode.isSubTotals &&
            !node.isSubTotals &&
            !hiddenColumnsInfo) {
            hierarchy.sampleNodesForAllLevels.push(node);
            hierarchy.maxLevel = level;
            // 如果当前是隐藏节点, 则采样其兄弟节点
            hierarchy.sampleNodeForLastLevel = node;
        }
        const isLeafNode = isLeaf || isCollapsed || !expandCurrentNode;
        if (isLeafNode) {
            node.isLeaf = true;
            hierarchy.pushIndexNode(node);
            node.rowIndex = hierarchy.getIndexNodes().length - 1;
        }
        else {
            handler === null || handler === void 0 ? void 0 : handler({
                addTotalMeasureInTotal,
                addMeasureInTotalQuery,
                parentNode: node,
                currentField: fields[level + 1],
                fields,
                hierarchy,
                spreadsheet,
            });
        }
    }
};
exports.generateHeaderNodes = generateHeaderNodes;
//# sourceMappingURL=generate-header-nodes.js.map