"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataCellMultiSelection = void 0;
const lodash_1 = require("lodash");
const constant_1 = require("../common/constant");
const select_event_1 = require("../utils/interaction/select-event");
const tooltip_1 = require("../utils/tooltip");
const base_interaction_1 = require("./base-interaction");
class DataCellMultiSelection extends base_interaction_1.BaseEvent {
    constructor() {
        super(...arguments);
        this.isMultiSelection = false;
    }
    bindEvents() {
        this.bindKeyboardDown();
        this.bindDataCellClick();
        this.bindKeyboardUp();
        this.bindMouseMove();
    }
    reset() {
        this.isMultiSelection = false;
        this.spreadsheet.interaction.removeIntercepts([constant_1.InterceptType.CLICK]);
    }
    bindKeyboardDown() {
        this.spreadsheet.on(constant_1.S2Event.GLOBAL_KEYBOARD_DOWN, (event) => {
            if ((0, select_event_1.isMultiSelectionKey)(event)) {
                this.isMultiSelection = true;
                this.spreadsheet.interaction.addIntercepts([constant_1.InterceptType.CLICK]);
            }
        });
    }
    bindKeyboardUp() {
        this.spreadsheet.on(constant_1.S2Event.GLOBAL_KEYBOARD_UP, (event) => {
            if ((0, select_event_1.isMultiSelectionKey)(event)) {
                this.reset();
            }
        });
    }
    bindMouseMove() {
        this.spreadsheet.on(constant_1.S2Event.GLOBAL_MOUSE_MOVE, (event) => {
            // 当快捷键被系统拦截后，按需补充调用一次 reset
            if (this.isMultiSelection && !(0, select_event_1.isMouseEventWithMeta)(event)) {
                this.reset();
            }
        });
    }
    getSelectedCells(cell) {
        const id = cell.getMeta().id;
        const { interaction } = this.spreadsheet;
        let selectedCells = interaction.getCells([constant_1.CellType.DATA_CELL]);
        let cells = [];
        if (interaction.getCurrentStateName() !== constant_1.InteractionStateName.SELECTED) {
            selectedCells = [];
        }
        if (selectedCells.find((meta) => meta.id === id)) {
            cells = selectedCells.filter((item) => item.id !== id);
        }
        else {
            cells = [...selectedCells, (0, select_event_1.getCellMeta)(cell)];
        }
        return cells;
    }
    bindDataCellClick() {
        this.spreadsheet.on(constant_1.S2Event.DATA_CELL_CLICK, (event) => {
            event.stopPropagation();
            const cell = this.spreadsheet.getCell(event.target);
            const meta = cell.getMeta();
            const { interaction } = this.spreadsheet;
            if (this.isMultiSelection && meta) {
                const selectedCells = this.getSelectedCells(cell);
                if ((0, lodash_1.isEmpty)(selectedCells)) {
                    interaction.clearState();
                    this.spreadsheet.hideTooltip();
                    interaction.emitSelectEvent({
                        event,
                        targetCell: cell,
                        interactionName: constant_1.InteractionName.DATA_CELL_MULTI_SELECTION,
                    });
                    return;
                }
                interaction.addIntercepts([constant_1.InterceptType.CLICK, constant_1.InterceptType.HOVER]);
                this.spreadsheet.hideTooltip();
                interaction.changeState({
                    cells: selectedCells,
                    stateName: constant_1.InteractionStateName.SELECTED,
                    onUpdateCells: select_event_1.afterSelectDataCells,
                });
                interaction.emitSelectEvent({
                    event,
                    targetCell: cell,
                    interactionName: constant_1.InteractionName.DATA_CELL_MULTI_SELECTION,
                });
                this.spreadsheet.showTooltipWithInfo(event, (0, tooltip_1.getCellsTooltipData)(this.spreadsheet));
            }
        });
    }
}
exports.DataCellMultiSelection = DataCellMultiSelection;
//# sourceMappingURL=data-cell-multi-selection.js.map