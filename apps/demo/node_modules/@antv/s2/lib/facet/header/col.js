"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ColHeader = void 0;
const g_1 = require("@antv/g");
const lodash_1 = require("lodash");
const col_cell_1 = require("../../cell/col-cell");
const pool_1 = require("../../cell/pool");
const constant_1 = require("../../common/constant");
const utils_1 = require("../utils");
const base_1 = require("./base");
const util_1 = require("./util");
/**
 * Column Header for SpreadSheet
 */
class ColHeader extends base_1.BaseHeader {
    constructor() {
        super(...arguments);
        this.colCellPool = new pool_1.ColCellPool();
    }
    initGroups() {
        this.scrollGroup = this.appendChild(new g_1.Group({
            name: constant_1.KEY_GROUP_COL_SCROLL,
            style: { zIndex: constant_1.FRONT_GROUND_GROUP_SCROLL_Z_INDEX },
        }));
        this.frozenGroup = this.appendChild(new g_1.Group({
            name: constant_1.KEY_GROUP_COL_FROZEN,
            style: { zIndex: constant_1.FRONT_GROUND_GROUP_FROZEN_Z_INDEX },
        }));
        this.frozenTrailingGroup = this.appendChild(new g_1.Group({
            name: constant_1.KEY_GROUP_COL_FROZEN_TRAILING,
            style: { zIndex: constant_1.FRONT_GROUND_GROUP_FROZEN_Z_INDEX },
        }));
        this.extraFrozenNodes = (0, util_1.getExtraFrozenColNodes)(this.headerConfig.spreadsheet.facet);
    }
    getCellGroup(node) {
        if (node.isFrozenHead) {
            return this.frozenGroup;
        }
        if (node.isFrozenTrailing) {
            return this.frozenTrailingGroup;
        }
        return this.scrollGroup;
    }
    getCellInstance(node) {
        var _a;
        if (this.colCellPool.pool.length > 0 &&
            ((_a = this.headerConfig.spreadsheet.options.future) === null || _a === void 0 ? void 0 : _a.experimentalReuseCell)) {
            const colCell = this.colCellPool.acquire();
            colCell.reInitCell(node, this.getHeaderConfig());
            return colCell;
        }
        const headerConfig = this.getHeaderConfig();
        const { spreadsheet } = this.getHeaderConfig();
        const { colCell } = spreadsheet.options;
        return ((colCell === null || colCell === void 0 ? void 0 : colCell(node, spreadsheet, headerConfig)) ||
            new col_cell_1.ColCell(node, spreadsheet, headerConfig));
    }
    appendNode(node) {
        var _a;
        const { spreadsheet } = this.getHeaderConfig();
        const group = this.getCellGroup(node);
        let cell;
        if (((_a = node.belongsCell) === null || _a === void 0 ? void 0 : _a.parentNode) === group &&
            node.belongsCell.getMeta() === node) {
            cell = node.belongsCell;
            cell.setHeaderConfig(this.headerConfig);
        }
        else {
            cell = this.getCellInstance(node);
            node.belongsCell = cell;
            if (cell.parentElement !== group) {
                group === null || group === void 0 ? void 0 : group.appendChild(cell);
            }
        }
        spreadsheet.emit(constant_1.S2Event.COL_CELL_RENDER, cell);
        spreadsheet.emit(constant_1.S2Event.LAYOUT_CELL_RENDER, cell);
    }
    layout() {
        const { nodes } = this.getHeaderConfig();
        (0, lodash_1.each)(nodes, (node) => {
            if (this.isColCellInRect(node)) {
                this.appendNode(node);
            }
        });
        (0, lodash_1.each)(this.extraFrozenNodes, (node) => {
            this.appendNode(node);
        });
    }
    /**
     * Make colHeader scroll with hScrollBar
     * @param scrollX horizontal offset
     * @param cornerWidth only has real meaning when scroll contains rowCell
     * @param type
     */
    onColScroll(scrollX, type) {
        if (this.headerConfig.scrollX !== scrollX) {
            this.headerConfig.scrollX = scrollX;
            this.render(type);
        }
    }
    clip() {
        const { height, spreadsheet, position, viewportWidth, cornerWidth = 0, scrollX = 0, } = this.getHeaderConfig();
        const facet = spreadsheet.facet;
        const frozenGroupAreas = facet.frozenGroupAreas;
        const frozenColGroupWidth = frozenGroupAreas[constant_1.FrozenGroupArea.Col].width;
        const frozenTrailingColGroupWidth = frozenGroupAreas[constant_1.FrozenGroupArea.TrailingCol].width;
        const { x, width } = (0, util_1.getScrollGroupClip)(facet, position);
        this.createOrUpdate('scrollGroup.style.clipPath', {
            x,
            y: position.y,
            width,
            height,
        });
        this.createOrUpdate('frozenGroup.style.clipPath', {
            x: position.x - (0, util_1.getFrozenColOffset)(facet, cornerWidth, scrollX),
            y: position.y,
            width: frozenColGroupWidth,
            height,
        });
        this.createOrUpdate('frozenTrailingGroup.style.clipPath', {
            x: position.x + viewportWidth - frozenTrailingColGroupWidth,
            y: position.y,
            width: frozenTrailingColGroupWidth,
            height,
        });
    }
    isColCellInRect(node) {
        const { spreadsheet, cornerWidth = 0, viewportWidth, scrollX = 0, position, } = this.getHeaderConfig();
        const frozenGroupAreas = spreadsheet.facet
            .frozenGroupAreas;
        let leftBoundary;
        const frozenColWidth = frozenGroupAreas[constant_1.FrozenGroupArea.Col].width;
        const frozenTrailingColWidth = frozenGroupAreas[constant_1.FrozenGroupArea.TrailingCol].width;
        if (spreadsheet.isFrozenRowHeader()) {
            leftBoundary = frozenColWidth;
        }
        else if (frozenColWidth) {
            // 如果存在列冻结，那么 frame 最多滚动到最左侧，即滚动 cornerWidth 的宽度
            leftBoundary = frozenColWidth - cornerWidth;
        }
        else {
            leftBoundary = -position.x;
        }
        return (
        // don't care about scrollY, because there is only freeze col-header exist
        viewportWidth - frozenTrailingColWidth >= node.x - scrollX &&
            leftBoundary <= node.x + node.width - scrollX);
    }
    offset() {
        const { viewportWidth, scrollX = 0, position, spreadsheet, cornerWidth, } = this.getHeaderConfig();
        (0, utils_1.translateGroup)(this.scrollGroup, position.x - scrollX, position.y);
        const facet = spreadsheet.facet;
        const colOffset = (0, util_1.getFrozenColOffset)(facet, cornerWidth, scrollX);
        const trailingColOffset = (0, util_1.getFrozenTrailingColOffset)(facet, viewportWidth);
        (0, utils_1.translateGroup)(this.frozenGroup, position.x - colOffset, position.y);
        (0, utils_1.translateGroup)(this.frozenTrailingGroup, position.x - trailingColOffset, position.y);
    }
    clear() {
        var _a;
        if ((_a = this.headerConfig.spreadsheet.options.future) === null || _a === void 0 ? void 0 : _a.experimentalReuseCell) {
            // @ts-ignore
            this.scrollGroup.childNodes.forEach((colCell) => {
                if (!this.isColCellInRect(colCell.getMeta())) {
                    colCell.getMeta().belongsCell = null;
                    this.colCellPool.release(colCell);
                }
            });
        }
        else {
            super.clear();
        }
    }
    clearResizeAreaGroup() { }
}
exports.ColHeader = ColHeader;
//# sourceMappingURL=col.js.map