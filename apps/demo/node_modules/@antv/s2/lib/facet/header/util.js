"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getScrollGroupClip = exports.getFrozenTrailingRowOffset = exports.getFrozenTrailingColOffset = exports.getFrozenColOffset = exports.getExtraFrozenColNodes = exports.getExtraFrozenSeriesNodes = exports.getExtraFrozenRowNodes = exports.getSeriesNumberNodes = void 0;
const lodash_1 = require("lodash");
const common_1 = require("../../common");
const node_1 = require("../layout/node");
const frame_1 = require("./frame");
const getSeriesNumberNodes = (rowsHierarchy, seriesNumberWidth, spreadsheet) => {
    const isHierarchyTreeType = spreadsheet.isHierarchyTreeType();
    const rootNodes = rowsHierarchy.getNodes(0);
    return rootNodes.map((node, idx) => {
        const value = `${idx + 1}`;
        const sNode = new node_1.Node({
            id: value,
            field: '',
            rowIndex: idx,
            value,
        });
        sNode.x = node.x;
        sNode.y = node.y;
        sNode.width = seriesNumberWidth;
        sNode.height = isHierarchyTreeType
            ? node.getTotalHeightForTreeHierarchy()
            : node.height;
        sNode.isLeaf = true;
        sNode.relatedNode = node;
        sNode.spreadsheet = spreadsheet;
        return sNode;
    });
};
exports.getSeriesNumberNodes = getSeriesNumberNodes;
const getAllParents = (nodes) => {
    const parents = nodes.reduce((pre, leaf) => {
        let parent = leaf.parent;
        while (parent && parent.id !== common_1.ROOT_NODE_ID) {
            // eslint-disable-next-line no-loop-func
            if (!pre.find((node) => node.id === parent.id)) {
                pre.push(parent);
            }
            parent = parent.parent;
        }
        return pre;
    }, []);
    return parents;
};
const clipFrozenRowHeadNode = (node, { y = 0, height = 0 }) => {
    if (node.y < y) {
        node.height -= y - node.y;
        node.y = y;
    }
    if (node.y + node.height > y + height) {
        node.height -= node.y + node.height - y - height;
    }
};
const clipFrozenTrailingRowHeadNode = (node, { y = 0, height = 0 }) => {
    if (node.y + node.height > y + height) {
        node.height -= node.y + node.height - y - height;
    }
    if (node.y < y) {
        node.height -= y - node.y;
        node.y = y;
    }
};
const getExtraFrozenRowNodes = (facet) => {
    const extraNodes = [];
    const { start, end } = facet.getCellRange();
    const { rowCount, trailingRowCount } = facet.getFrozenOptions();
    if (rowCount) {
        const frozenLeafNodes = facet.getRowLeafNodesByRange(start, start + rowCount - 1);
        frozenLeafNodes.forEach((leafNode) => {
            const newLeafNode = leafNode.clone();
            newLeafNode.isFrozenHead = true;
            extraNodes.push(newLeafNode);
        });
        const parents = getAllParents(frozenLeafNodes);
        parents.forEach((parent) => {
            const newParent = parent.clone();
            newParent.isFrozenHead = true;
            clipFrozenRowHeadNode(newParent, facet.frozenGroupAreas[common_1.FrozenGroupArea.Row]);
            extraNodes.push(newParent);
        });
    }
    if (trailingRowCount) {
        const frozenLeafNodes = facet.getRowLeafNodesByRange(end - trailingRowCount + 1, end);
        frozenLeafNodes.forEach((leafNode) => {
            const newLeafNode = leafNode.clone();
            newLeafNode.isFrozenTrailing = true;
            extraNodes.push(newLeafNode);
        });
        const parents = getAllParents(frozenLeafNodes);
        parents.forEach((parent) => {
            const newParent = parent.clone();
            newParent.isFrozenTrailing = true;
            clipFrozenTrailingRowHeadNode(newParent, facet.frozenGroupAreas[common_1.FrozenGroupArea.TrailingRow]);
            extraNodes.push(newParent);
        });
    }
    return extraNodes;
};
exports.getExtraFrozenRowNodes = getExtraFrozenRowNodes;
const getExtraFrozenSeriesNodes = (facet, nodes) => {
    const extraNodes = [];
    const { start, end } = facet.getCellRange();
    const { rowCount, trailingRowCount } = facet.getFrozenOptions();
    const includeChildInRowIndexRange = (node, range) => {
        var _a;
        const rowIdx = node.rowIndex;
        if ((0, lodash_1.isNumber)(rowIdx) && rowIdx >= range[0] && rowIdx <= range[1]) {
            return true;
        }
        const children = (_a = node.children) !== null && _a !== void 0 ? _a : [];
        for (let i = 0; i < children.length; i++) {
            if (includeChildInRowIndexRange(children[i], range)) {
                return true;
            }
        }
        return false;
    };
    if (rowCount) {
        const range = [start, start + rowCount - 1];
        nodes.forEach((node) => {
            if (node.relatedNode &&
                !includeChildInRowIndexRange(node.relatedNode, range)) {
                return;
            }
            const newNode = node.clone();
            newNode.isFrozenHead = true;
            clipFrozenRowHeadNode(newNode, facet.frozenGroupAreas[common_1.FrozenGroupArea.Row]);
            extraNodes.push(newNode);
        });
    }
    if (trailingRowCount) {
        const range = [end - trailingRowCount + 1, end];
        nodes.forEach((node) => {
            if (node.relatedNode &&
                !includeChildInRowIndexRange(node.relatedNode, range)) {
                return;
            }
            const newNode = node.clone();
            newNode.isFrozenTrailing = true;
            clipFrozenTrailingRowHeadNode(newNode, facet.frozenGroupAreas[common_1.FrozenGroupArea.TrailingRow]);
            extraNodes.push(newNode);
        });
    }
    return extraNodes;
};
exports.getExtraFrozenSeriesNodes = getExtraFrozenSeriesNodes;
const getExtraFrozenColNodes = (facet) => {
    const extraNodes = [];
    const { colCount, trailingColCount } = facet.getFrozenOptions();
    if (colCount) {
        const { x, width } = facet.frozenGroupAreas[common_1.FrozenGroupArea.Col];
        const frozenLeafNodes = facet.getColLeafNodesByRange(0, colCount - 1);
        frozenLeafNodes.forEach((leafNode) => {
            const newLeafNode = leafNode.clone();
            newLeafNode.isFrozenHead = true;
            extraNodes.push(newLeafNode);
        });
        const parents = getAllParents(frozenLeafNodes);
        parents.forEach((parent) => {
            const newParent = parent.clone();
            newParent.isFrozenHead = true;
            if (newParent.x < x) {
                newParent.width -= x - newParent.x;
                newParent.x = x;
            }
            if (newParent.x + newParent.width > x + width) {
                newParent.width -= newParent.x + newParent.width - x - width;
            }
            extraNodes.push(newParent);
        });
    }
    if (trailingColCount) {
        const { x, width } = facet.frozenGroupAreas[common_1.FrozenGroupArea.TrailingCol];
        const total = facet.getColLeafNodes().length;
        const frozenLeafNodes = facet.getColLeafNodesByRange(total - trailingColCount, total - 1);
        frozenLeafNodes.forEach((leafNode) => {
            const newLeafNode = leafNode.clone();
            newLeafNode.isFrozenTrailing = true;
            extraNodes.push(newLeafNode);
        });
        const parents = getAllParents(frozenLeafNodes);
        parents.forEach((parent) => {
            const newParent = parent.clone();
            newParent.isFrozenTrailing = true;
            if (newParent.x + newParent.width > x + width) {
                newParent.width -= newParent.x + newParent.width - x - width;
            }
            if (newParent.x < x) {
                newParent.width -= x - newParent.x;
                newParent.x = x;
            }
            extraNodes.push(newParent);
        });
    }
    return extraNodes;
};
exports.getExtraFrozenColNodes = getExtraFrozenColNodes;
const getFrozenColOffset = (facet, cornerWidth = 0, scrollX = 0) => {
    const isFrozenRowHeader = facet.spreadsheet.isFrozenRowHeader();
    if (isFrozenRowHeader) {
        return 0;
    }
    return scrollX <= cornerWidth ? scrollX : cornerWidth;
};
exports.getFrozenColOffset = getFrozenColOffset;
const getFrozenTrailingColOffset = (facet, viewportWidth) => {
    const trailingCol = facet.frozenGroupAreas[common_1.FrozenGroupArea.TrailingCol];
    const trailingColWidth = trailingCol.x + trailingCol.width;
    const trailingColOffset = viewportWidth > trailingColWidth ? 0 : trailingColWidth - viewportWidth;
    return trailingColOffset;
};
exports.getFrozenTrailingColOffset = getFrozenTrailingColOffset;
const getFrozenTrailingRowOffset = (facet, viewportHeight, paginationScrollY) => {
    const trailingRow = facet.frozenGroupAreas[common_1.FrozenGroupArea.TrailingRow];
    const trailingRowHeight = trailingRow.y + trailingRow.height - paginationScrollY;
    const trailingRowOffset = viewportHeight > trailingRowHeight
        ? paginationScrollY
        : paginationScrollY + trailingRowHeight - viewportHeight;
    return trailingRowOffset;
};
exports.getFrozenTrailingRowOffset = getFrozenTrailingRowOffset;
const getScrollGroupClip = (facet, position) => {
    const isFrozenRowHeader = facet.spreadsheet.isFrozenRowHeader();
    const frozenGroupAreas = facet.frozenGroupAreas;
    const frozenColGroupWidth = frozenGroupAreas[common_1.FrozenGroupArea.Col].width;
    const frozenTrailingColGroupWidth = frozenGroupAreas[common_1.FrozenGroupArea.TrailingCol].width;
    let x;
    if (isFrozenRowHeader) {
        x = position.x + frozenColGroupWidth;
    }
    else if (frozenColGroupWidth) {
        x = frame_1.Frame.getVerticalBorderWidth(facet.spreadsheet) + frozenColGroupWidth;
    }
    else {
        x = 0;
    }
    const viewportWidth = facet.panelBBox.viewportWidth;
    return {
        x,
        width: (isFrozenRowHeader ? viewportWidth : position.x + viewportWidth) -
            frozenColGroupWidth -
            frozenTrailingColGroupWidth,
    };
};
exports.getScrollGroupClip = getScrollGroupClip;
//# sourceMappingURL=util.js.map