"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RowHeader = void 0;
const g_1 = require("@antv/g");
const lodash_1 = require("lodash");
const cell_1 = require("../../cell");
const pool_1 = require("../../cell/pool");
const common_1 = require("../../common");
const utils_1 = require("../utils");
const base_1 = require("./base");
const util_1 = require("./util");
/**
 * Row Header for SpreadSheet
 */
class RowHeader extends base_1.BaseHeader {
    constructor() {
        super(...arguments);
        this.rowCellPool = new pool_1.RowCellPool();
    }
    initGroups() {
        this.scrollGroup = this.appendChild(new g_1.Group({
            name: common_1.KEY_GROUP_ROW_SCROLL,
            style: { zIndex: common_1.FRONT_GROUND_GROUP_SCROLL_Z_INDEX },
        }));
        this.frozenGroup = this.appendChild(new g_1.Group({
            name: common_1.KEY_GROUP_ROW_FROZEN,
            style: { zIndex: common_1.FRONT_GROUND_GROUP_FROZEN_Z_INDEX },
        }));
        this.frozenTrailingGroup = this.appendChild(new g_1.Group({
            name: common_1.KEY_GROUP_ROW_FROZEN_TRAILING,
            style: { zIndex: common_1.FRONT_GROUND_GROUP_FROZEN_Z_INDEX },
        }));
        const { spreadsheet } = this.getHeaderConfig();
        this.extraFrozenNodes = (0, util_1.getExtraFrozenRowNodes)(spreadsheet.facet);
    }
    getCellInstance(node) {
        var _a;
        if (this.rowCellPool.pool.length > 0 &&
            ((_a = this.headerConfig.spreadsheet.options.future) === null || _a === void 0 ? void 0 : _a.experimentalReuseCell)) {
            const rowCell = this.rowCellPool.acquire();
            rowCell.reInitCell(node, this.headerConfig);
            return rowCell;
        }
        const headerConfig = this.getHeaderConfig();
        const { spreadsheet } = headerConfig;
        const { rowCell } = spreadsheet.options;
        return ((rowCell === null || rowCell === void 0 ? void 0 : rowCell(node, spreadsheet, headerConfig)) ||
            new cell_1.RowCell(node, spreadsheet, headerConfig));
    }
    // row'cell only show when visible
    isCellInRect(node) {
        const { width, viewportHeight, position, scrollY = 0, scrollX = 0, spreadsheet, } = this.getHeaderConfig();
        const frozenGroupAreas = spreadsheet.facet
            .frozenGroupAreas;
        return (
        // bottom
        viewportHeight +
            scrollY -
            frozenGroupAreas[common_1.FrozenGroupArea.TrailingRow].height >
            node.y &&
            // top
            scrollY + frozenGroupAreas[common_1.FrozenGroupArea.Row].height <
                node.y + node.height &&
            // left
            width + scrollX - position.x > node.x &&
            // right
            scrollX - position.x < node.x + node.width);
    }
    getCellGroup(item) {
        if (item.isFrozenHead) {
            return this.frozenGroup;
        }
        if (item.isFrozenTrailing) {
            return this.frozenTrailingGroup;
        }
        return this.scrollGroup;
    }
    layout() {
        const { nodes } = this.getHeaderConfig();
        const appendNode = (node) => {
            var _a;
            const group = this.getCellGroup(node);
            let cell;
            if (((_a = node.belongsCell) === null || _a === void 0 ? void 0 : _a.parentNode) === group &&
                node.belongsCell.getMeta() === node) {
                cell = node.belongsCell;
                cell.setHeaderConfig(this.headerConfig);
                cell.updateTextPosition();
            }
            else {
                cell = this.getCellInstance(node);
                node.belongsCell = cell;
                if (cell.parentElement !== group) {
                    group === null || group === void 0 ? void 0 : group.appendChild(cell);
                }
            }
            this.emitRenderEvent(cell);
        };
        // row'cell only show when visible
        (0, lodash_1.each)(nodes, (node) => {
            if (this.isCellInRect(node) && node.height !== 0) {
                appendNode(node);
            }
        });
        (0, lodash_1.each)(this.extraFrozenNodes, (node) => {
            if (node.height !== 0) {
                appendNode(node);
            }
        });
    }
    emitRenderEvent(cell) {
        const { spreadsheet } = this.getHeaderConfig();
        spreadsheet.emit(common_1.S2Event.ROW_CELL_RENDER, cell);
        spreadsheet.emit(common_1.S2Event.LAYOUT_CELL_RENDER, cell);
    }
    offset() {
        const { scrollX = 0, scrollY = 0, position, spreadsheet, viewportHeight, } = this.getHeaderConfig();
        const translateX = position.x - scrollX;
        const paginationScrollY = spreadsheet.facet.getPaginationScrollY();
        const facet = spreadsheet.facet;
        const trailingRowOffset = (0, util_1.getFrozenTrailingRowOffset)(facet, viewportHeight, paginationScrollY);
        (0, utils_1.translateGroup)(this.scrollGroup, translateX, position.y - scrollY);
        (0, utils_1.translateGroup)(this.frozenGroup, translateX, position.y - paginationScrollY);
        (0, utils_1.translateGroup)(this.frozenTrailingGroup, translateX, position.y - trailingRowOffset);
    }
    clip() {
        const { width, viewportHeight, position, spreadsheet } = this.getHeaderConfig();
        const frozenGroupAreas = spreadsheet.facet
            .frozenGroupAreas;
        const frozenRowGroupHeight = frozenGroupAreas[common_1.FrozenGroupArea.Row].height;
        const frozenTrailingRowGroupHeight = frozenGroupAreas[common_1.FrozenGroupArea.TrailingRow].height;
        this.createOrUpdate('scrollGroup.style.clipPath', {
            x: spreadsheet.facet.cornerBBox.x,
            y: position.y + frozenRowGroupHeight,
            width,
            height: viewportHeight - frozenRowGroupHeight - frozenTrailingRowGroupHeight,
        });
        this.createOrUpdate('frozenGroup.style.clipPath', {
            x: spreadsheet.facet.cornerBBox.x,
            y: position.y,
            width,
            height: frozenRowGroupHeight,
        });
        this.createOrUpdate('frozenTrailingGroup.style.clipPath', {
            x: spreadsheet.facet.cornerBBox.x,
            y: position.y + viewportHeight - frozenTrailingRowGroupHeight,
            width,
            height: frozenTrailingRowGroupHeight,
        });
    }
    clear() {
        var _a;
        if ((_a = this.headerConfig.spreadsheet.options.future) === null || _a === void 0 ? void 0 : _a.experimentalReuseCell) {
            // @ts-ignore
            this.scrollGroup.childNodes.forEach((rowCell) => {
                if (!this.isCellInRect(rowCell.getMeta())) {
                    rowCell.getMeta().belongsCell = null;
                    this.rowCellPool.release(rowCell);
                }
            });
        }
        else {
            super.clear();
        }
    }
}
exports.RowHeader = RowHeader;
//# sourceMappingURL=row.js.map