"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CornerBBox = void 0;
const lodash_1 = require("lodash");
const constant_1 = require("../../common/constant");
const math_1 = require("../../utils/math");
const base_bbox_1 = require("./base-bbox");
class CornerBBox extends base_bbox_1.BaseBBox {
    calculateBBox() {
        const width = this.getWidth();
        const height = this.getHeight();
        this.width = width;
        this.height = height;
        this.maxX = width;
        this.maxY = height;
    }
    calculateOriginalHeight() {
        var _a;
        const { colsHierarchy } = this.layoutResult;
        const { colCell } = this.spreadsheet.options.style;
        /**
         * 角头分为两部分, 一部分对应行头, 一部分对应列头, 角头的叶子节点对应行头节点, 以下极端情况让没有列头的时候也能 [行头对应的角头] 正常显示
         * 1. 只配置了 rows, 而 columns, values 都为空, 此时列头为空
         * 2. 配置了 rows, values, 此时存在一级列头 (即 EXTRA_FIELD 数值节点), 但是隐藏了数值 (hideMeasureColumn), 此时列头为空
         */
        if (!colsHierarchy.sampleNodeForLastLevel) {
            this.originalHeight =
                (_a = this.facet.getCellCustomSize(null, colCell === null || colCell === void 0 ? void 0 : colCell.height)) !== null && _a !== void 0 ? _a : 0;
        }
        else {
            this.originalHeight = (0, math_1.floor)(colsHierarchy.height);
        }
    }
    calculateOriginWidth() {
        const { rowsHierarchy } = this.layoutResult;
        this.originalWidth = (0, math_1.floor)(rowsHierarchy.width + this.facet.getSeriesNumberWidth());
    }
    getHeight() {
        this.calculateOriginalHeight();
        return this.originalHeight;
    }
    getWidth() {
        this.calculateOriginWidth();
        // 在行头固定时，需对角头 BBox 进行裁剪
        if (this.spreadsheet.isFrozenRowHeader()) {
            return this.adjustWidth();
        }
        return this.originalWidth;
    }
    adjustWidth() {
        const { colsHierarchy } = this.layoutResult;
        const { width: canvasWidth, frozen } = this.spreadsheet.options;
        const rowHeader = frozen === null || frozen === void 0 ? void 0 : frozen.rowHeader;
        const ratio = (0, lodash_1.isBoolean)(rowHeader)
            ? constant_1.DEFAULT_CORNER_MAX_WIDTH_RATIO
            : (0, lodash_1.clamp)(rowHeader, 0, 1);
        const maxCornerBBoxWidth = canvasWidth * ratio;
        const colsHierarchyWidth = colsHierarchy === null || colsHierarchy === void 0 ? void 0 : colsHierarchy.width;
        const panelWidthWithoutUnClippedCorner = canvasWidth - this.originalWidth;
        /*
         * 不需要裁剪条件：
         * 1. 角头的宽度没有超过最大的角头范围
         * 2. 列头的宽度没有超过在不裁剪角头前提下的剩余范围
         */
        if (this.originalWidth <= maxCornerBBoxWidth ||
            colsHierarchyWidth <= panelWidthWithoutUnClippedCorner) {
            return this.originalWidth;
        }
        let clippedWidth = 0;
        const maxPanelWidth = canvasWidth - maxCornerBBoxWidth;
        // 列头宽度超过了剩余宽度，但是小于 Panel 的最大宽度
        if (colsHierarchyWidth <= maxPanelWidth) {
            clippedWidth =
                this.originalWidth -
                    (colsHierarchyWidth - panelWidthWithoutUnClippedCorner);
        }
        else {
            clippedWidth = maxCornerBBoxWidth;
        }
        return (0, math_1.floor)(clippedWidth);
    }
}
exports.CornerBBox = CornerBBox;
//# sourceMappingURL=corner-bbox.js.map