"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Hierarchy = void 0;
const node_1 = require("./node");
/**
 * Row and Column hierarchy to handle all contained nodes
 */
class Hierarchy {
    constructor() {
        // the full width contains all nodes
        this.width = 0;
        // the full height contains all nodes
        this.height = 0;
        // just a mark to get node from each level
        this.maxLevel = -1;
        // each level's first node
        this.sampleNodesForAllLevels = [];
        // last level's first node
        this.sampleNodeForLastLevel = null;
        // all nodes in this hierarchy
        this.allNodesWithoutRoot = [];
        // all nodes in the lastLevel
        this.indexNode = [];
        this.isPlaceholder = false;
        this.rootNode = node_1.Node.rootNode();
    }
    // get all leaf nodes
    getLeaves() {
        return this.allNodesWithoutRoot.filter((node) => node.isLeaf);
    }
    /**
     * Get all or level-related nodes in hierarchy
     * @param level
     */
    getNodes(level) {
        if (level !== undefined) {
            return this.allNodesWithoutRoot.filter((node) => node.level === level);
        }
        return this.allNodesWithoutRoot;
    }
    /**
     * Get all or less than level-related nodes in hierarchy
     * @param lessThanLevel
     */
    getNodesLessThanLevel(lessThanLevel) {
        return this.allNodesWithoutRoot.filter((node) => node.level <= lessThanLevel);
    }
    /**
     * Add new node
     * @param node
     * @param insetIndex
     */
    pushNode(node, insetIndex = -1) {
        if (insetIndex === -1) {
            this.allNodesWithoutRoot.push(node);
        }
        else {
            this.allNodesWithoutRoot.splice(insetIndex, 0, node);
        }
    }
    pushIndexNode(node) {
        this.indexNode.push(node);
    }
    getIndexNodes() {
        return this.indexNode;
    }
}
exports.Hierarchy = Hierarchy;
//# sourceMappingURL=hierarchy.js.map