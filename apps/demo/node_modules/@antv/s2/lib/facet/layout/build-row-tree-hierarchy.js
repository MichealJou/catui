"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildRowTreeHierarchy = void 0;
const lodash_1 = require("lodash");
const common_1 = require("../../common");
const data_set_operate_1 = require("../../utils/data-set-operate");
const generate_id_1 = require("../../utils/layout/generate-id");
const layout_hooks_1 = require("../layout/layout-hooks");
const node_1 = require("../layout/node");
const total_class_1 = require("../layout/total-class");
const addTotals = (spreadsheet, currentField, fieldValues) => {
    const totalsConfig = spreadsheet.getTotalsConfig(currentField);
    /**
     * tree mode only has grand totals, but if there are subTotals configs,
     * it will display in cross-area cell
     */
    if (totalsConfig === null || totalsConfig === void 0 ? void 0 : totalsConfig.showGrandTotals) {
        const func = totalsConfig.reverseGrandTotalsLayout ? 'unshift' : 'push';
        fieldValues[func](new total_class_1.TotalClass({
            label: totalsConfig.grandTotalsLabel,
            isGrandTotals: true,
            isSubTotals: false,
            isTotalRoot: false,
        }));
    }
};
/**
 * Only row header has tree hierarchy, in this scene:
 * 1、value in rows is not work => valueInCols is ineffective
 * 2、can't add extra sub total node in row
 * @param params
 */
const buildRowTreeHierarchy = (params) => {
    var _a, _b, _c, _d, _e, _f, _g;
    const { spreadsheet, parentNode, currentField, level, hierarchy, pivotMeta } = params;
    const { query, id: parentId } = parentNode;
    const isDrillDownItem = ((_c = (_b = (_a = spreadsheet.dataCfg) === null || _a === void 0 ? void 0 : _a.fields) === null || _b === void 0 ? void 0 : _b.rows) === null || _c === void 0 ? void 0 : _c.length) <= level;
    const dimValues = (0, data_set_operate_1.filterOutDetail)(Array.from(pivotMeta.keys()));
    let fieldValues = (0, layout_hooks_1.layoutArrange)(spreadsheet, dimValues, parentNode, currentField);
    // limit displayed drill down data by drillItemsNum
    const drillItemsNum = spreadsheet.store.get('drillItemsNum');
    if (isDrillDownItem && drillItemsNum > 0) {
        fieldValues = fieldValues.slice(0, drillItemsNum);
    }
    if (level === 0) {
        addTotals(spreadsheet, currentField, fieldValues);
    }
    for (const fieldValue of fieldValues) {
        const isTotals = fieldValue instanceof total_class_1.TotalClass;
        const pivotMetaValue = isTotals
            ? null
            : pivotMeta.get(fieldValue);
        let value;
        let nodeQuery = query;
        let isGrandTotals = false;
        let isSubTotals = false;
        if (isTotals) {
            const totalClass = fieldValue;
            isGrandTotals = totalClass.isGrandTotals;
            isSubTotals = totalClass.isSubTotals;
            value = (0, common_1.i18n)(fieldValue.label);
            nodeQuery = query;
        }
        else {
            value = fieldValue;
            nodeQuery = Object.assign(Object.assign({}, query), { [currentField]: value });
        }
        const nodeId = (0, generate_id_1.generateId)(parentId, value);
        const { collapseFields, collapseAll, expandDepth } = (_d = spreadsheet.options.style) === null || _d === void 0 ? void 0 : _d.rowCell;
        /**
         * 行头收起/展开配置优先级:collapseFields -> expandDepth -> collapseAll
         * 优先从读取 collapseFields 中的特定 node 的值
         * 如果没有特定配置，再查看是否配置了层级展开配置，
         * 最后再降级到 collapseAll 中
         */
        const isDefaultCollapsed = (_e = collapseFields === null || collapseFields === void 0 ? void 0 : collapseFields[nodeId]) !== null && _e !== void 0 ? _e : collapseFields === null || collapseFields === void 0 ? void 0 : collapseFields[currentField];
        // 如果 level 大于 rowExpandDepth 或者没有配置层级展开配置时，返回 null，保证能正确降级到 collapseAll
        const isLevelCollapsed = (0, lodash_1.isNumber)(expandDepth) ? level > expandDepth : null;
        const isCollapsed = (_f = isDefaultCollapsed !== null && isDefaultCollapsed !== void 0 ? isDefaultCollapsed : isLevelCollapsed) !== null && _f !== void 0 ? _f : collapseAll;
        const node = new node_1.Node({
            id: nodeId,
            value,
            level,
            parent: parentNode,
            field: currentField,
            isTotals,
            isGrandTotals,
            isSubTotals,
            isCollapsed,
            hierarchy,
            query: nodeQuery,
            spreadsheet,
        });
        if (level > hierarchy.maxLevel) {
            hierarchy.maxLevel = level;
        }
        /**
         * 除了虚拟行小计节点外, 如果为空, 说明当前分组只有一条数据, 应该标记为叶子节点.
         * https://github.com/antvis/S2/issues/2804
         */
        const children = [...(((_g = pivotMetaValue === null || pivotMetaValue === void 0 ? void 0 : pivotMetaValue.children) === null || _g === void 0 ? void 0 : _g.keys()) || [])].filter((child) => child !== common_1.TOTAL_VALUE);
        const isEmptyChildren = (0, lodash_1.isEmpty)(children);
        if (isEmptyChildren || isTotals) {
            node.isLeaf = true;
        }
        if (!isEmptyChildren) {
            node.isTotals = true;
        }
        const expandCurrentNode = (0, layout_hooks_1.layoutHierarchy)(spreadsheet, parentNode, node, hierarchy);
        if (!isEmptyChildren && !isCollapsed && !isTotals && expandCurrentNode) {
            (0, exports.buildRowTreeHierarchy)({
                level: level + 1,
                currentField: pivotMetaValue.childField,
                pivotMeta: pivotMetaValue.children,
                parentNode: node,
                hierarchy,
                spreadsheet,
            });
        }
    }
};
exports.buildRowTreeHierarchy = buildRowTreeHierarchy;
//# sourceMappingURL=build-row-tree-hierarchy.js.map