"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildGridHierarchy = void 0;
const lodash_1 = require("lodash");
const constant_1 = require("../../common/constant");
const data_set_operate_1 = require("../../utils/data-set-operate");
const add_totals_1 = require("../../utils/layout/add-totals");
const generate_header_nodes_1 = require("../../utils/layout/generate-header-nodes");
const get_dims_condition_by_node_1 = require("../../utils/layout/get-dims-condition-by-node");
const whether_leaf_by_level_1 = require("../../utils/layout/whether-leaf-by-level");
const layout_hooks_1 = require("../layout/layout-hooks");
const total_measure_1 = require("../layout/total-measure");
const total_class_1 = require("./total-class");
const buildTotalGridHierarchy = (params) => {
    const { addTotalMeasureInTotal, parentNode, currentField, fields, hierarchy, spreadsheet, } = params;
    const index = fields.indexOf(currentField);
    const dataSet = spreadsheet.dataSet;
    const { values = [] } = dataSet.fields;
    const fieldValues = [];
    let query = {};
    const totalsConfig = spreadsheet.getTotalsConfig(currentField);
    const defaultDimensionGroup = parentNode.isGrandTotals
        ? totalsConfig.grandTotalsGroupDimensions || []
        : totalsConfig.subTotalsGroupDimensions || [];
    const dimensionGroup = !dataSet.isEmpty() ? defaultDimensionGroup : [];
    if (dimensionGroup === null || dimensionGroup === void 0 ? void 0 : dimensionGroup.includes(currentField)) {
        query = (0, get_dims_condition_by_node_1.getDimsCondition)(parentNode);
        const dimValues = dataSet.getDimensionValues(currentField, query);
        fieldValues.push(...(dimValues || []).map((value) => new total_class_1.TotalClass({
            label: value,
            isSubTotals: parentNode.isSubTotals,
            isGrandTotals: parentNode.isGrandTotals,
            isTotalRoot: false,
        })));
        if ((0, lodash_1.isEmpty)(fieldValues) && currentField) {
            fieldValues.push(constant_1.EMPTY_FIELD_VALUE);
        }
    }
    else if (addTotalMeasureInTotal && currentField === constant_1.EXTRA_FIELD) {
        // add total measures
        query = (0, get_dims_condition_by_node_1.getDimsCondition)(parentNode);
        fieldValues.push(...values.map((v) => new total_measure_1.TotalMeasure(v)));
    }
    else if ((0, whether_leaf_by_level_1.whetherLeafByLevel)({ spreadsheet, level: index, fields })) {
        // 如果最后一级没有分组维度，则将上一个结点设为叶子节点
        parentNode.isLeaf = true;
        hierarchy.pushIndexNode(parentNode);
        parentNode.rowIndex = hierarchy.getIndexNodes().length - 1;
        return;
    }
    else {
        // 如果是空维度，则跳转到下一级 level
        buildTotalGridHierarchy(Object.assign(Object.assign({}, params), { currentField: fields[index + 1] }));
        return;
    }
    const displayFieldValues = (0, data_set_operate_1.filterOutDetail)(fieldValues);
    (0, generate_header_nodes_1.generateHeaderNodes)(Object.assign(Object.assign({}, params), { fieldValues: displayFieldValues, level: index, parentNode,
        query, 
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        handler: buildGridHierarchy }));
};
const buildNormalGridHierarchy = (params) => {
    const { parentNode, currentField, fields, spreadsheet } = params;
    const dataSet = spreadsheet.dataSet;
    const { values = [] } = dataSet.fields;
    const index = fields.indexOf(currentField);
    const fieldValues = [];
    let query = {};
    // field(dimension)'s all values
    query = (0, get_dims_condition_by_node_1.getDimsCondition)(parentNode, true);
    const dimValues = dataSet.getDimensionValues(currentField, query);
    const arrangedValues = (0, layout_hooks_1.layoutArrange)(spreadsheet, dimValues, parentNode, currentField);
    fieldValues.push(...(arrangedValues || []));
    // add skeleton for empty data
    if ((0, lodash_1.isEmpty)(fieldValues) && currentField) {
        if (currentField === constant_1.EXTRA_FIELD) {
            fieldValues.push(...values);
        }
        else {
            fieldValues.push(constant_1.EMPTY_FIELD_VALUE);
        }
    }
    (0, add_totals_1.addTotals)({
        currentField,
        lastField: fields[index - 1],
        isFirstField: index === 0,
        fieldValues,
        spreadsheet,
    });
    const displayFieldValues = (0, data_set_operate_1.filterOutDetail)(fieldValues);
    (0, generate_header_nodes_1.generateHeaderNodes)(Object.assign(Object.assign({}, params), { fieldValues: displayFieldValues, level: index, parentNode,
        query, 
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        handler: buildGridHierarchy }));
};
/**
 * Build grid hierarchy in rows or columns
 */
function buildGridHierarchy(params) {
    if (params.parentNode.isTotals) {
        buildTotalGridHierarchy(params);
    }
    else {
        buildNormalGridHierarchy(params);
    }
}
exports.buildGridHierarchy = buildGridHierarchy;
//# sourceMappingURL=build-gird-hierarchy.js.map