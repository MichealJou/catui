"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildHeaderHierarchy = void 0;
const lodash_1 = require("lodash");
const common_1 = require("../../common");
const build_gird_hierarchy_1 = require("./build-gird-hierarchy");
const build_row_custom_tree_hierarchy_1 = require("./build-row-custom-tree-hierarchy");
const build_row_tree_hierarchy_1 = require("./build-row-tree-hierarchy");
const build_table_hierarchy_1 = require("./build-table-hierarchy");
const hierarchy_1 = require("./hierarchy");
const handleCustomTreeHierarchy = (params) => {
    const { rootNode, hierarchy, fields, spreadsheet, isRowHeader } = params;
    // 自定义行/列 需要去除额外添加的 EXTRA_FIELD 虚拟数值字段, 即不参与布局, 只用于定位数据
    const withoutExtraFieldsTree = (0, lodash_1.filter)(fields, (field) => field !== common_1.EXTRA_FIELD);
    // custom tree header
    (0, build_row_custom_tree_hierarchy_1.buildCustomTreeHierarchy)({
        spreadsheet,
        tree: withoutExtraFieldsTree,
        level: 0,
        parentNode: rootNode,
        hierarchy,
        isRowHeader,
    });
};
const handleGridRowColHierarchy = (params) => {
    const { isValueInCols, moreThanOneValue, rootNode, hierarchy, fields, isRowHeader, isCustomTreeFields, spreadsheet, } = params;
    // add new total measure in total node
    let addTotalMeasureInTotal;
    // add measure info in total query
    let addMeasureInTotalQuery;
    if (isRowHeader) {
        addTotalMeasureInTotal = !isValueInCols && moreThanOneValue;
        addMeasureInTotalQuery = !isValueInCols && !moreThanOneValue;
    }
    else {
        addTotalMeasureInTotal = isValueInCols && moreThanOneValue;
        addMeasureInTotalQuery = isValueInCols && !moreThanOneValue;
    }
    if (isCustomTreeFields) {
        handleCustomTreeHierarchy(params);
    }
    else {
        (0, build_gird_hierarchy_1.buildGridHierarchy)({
            spreadsheet,
            addTotalMeasureInTotal,
            addMeasureInTotalQuery,
            parentNode: rootNode,
            currentField: fields[0],
            fields: fields,
            hierarchy,
        });
    }
};
const handleTreeRowHierarchy = (params) => {
    const { spreadsheet, rootNode, hierarchy, isCustomTreeFields } = params;
    const { rows } = spreadsheet.dataSet.fields;
    if (spreadsheet.isHierarchyTreeType() && !isCustomTreeFields) {
        // row tree hierarchy(value must stay in colHeader)
        (0, build_row_tree_hierarchy_1.buildRowTreeHierarchy)({
            level: 0,
            currentField: rows === null || rows === void 0 ? void 0 : rows[0],
            pivotMeta: spreadsheet.dataSet.rowPivotMeta,
            parentNode: rootNode,
            hierarchy,
            spreadsheet,
        });
    }
    else {
        handleCustomTreeHierarchy(params);
    }
};
const handleRowHeaderHierarchy = (params) => {
    // 只有透视表有行头
    const { spreadsheet } = params;
    if (spreadsheet.isHierarchyTreeType()) {
        handleTreeRowHierarchy(params);
    }
    else {
        handleGridRowColHierarchy(params);
    }
};
const handleTableHierarchy = (params) => {
    var _a;
    const { isCustomTreeFields, spreadsheet } = params;
    const { enable } = (_a = spreadsheet.options.seriesNumber) !== null && _a !== void 0 ? _a : {};
    if (isCustomTreeFields) {
        const seriesNumberField = {
            field: common_1.SERIES_NUMBER_FIELD,
            title: spreadsheet.getSeriesNumberText(),
        };
        const fields = enable
            ? [seriesNumberField, ...params.fields]
            : params.fields.filter((node) => (node === null || node === void 0 ? void 0 : node.field) !== common_1.SERIES_NUMBER_FIELD);
        handleCustomTreeHierarchy(Object.assign(Object.assign({}, params), { fields }));
        return;
    }
    (0, build_table_hierarchy_1.buildTableHierarchy)(params);
};
const handleColHeaderHierarchy = (params) => {
    const { spreadsheet } = params;
    const isPivotMode = spreadsheet.isPivotMode();
    if (isPivotMode) {
        handleGridRowColHierarchy(params);
    }
    else {
        handleTableHierarchy(params);
    }
};
/**
 * Header Hierarchy
 * - row header
 *   - tree layout
 *     - custom tree layout
 *   - grid layout
 *   - table layout
 * - col header
 *   - grid layout
 *     - single value
 *       - total + sub_total
 *     - more than one value
 *       - total + sub_total
 *         - separate by values
 *   - table layout
 * @param params
 */
const buildHeaderHierarchy = (params) => {
    const { isRowHeader, spreadsheet } = params;
    const { rows = [], columns = [] } = spreadsheet.dataSet.fields;
    const isValueInCols = spreadsheet.isValueInCols();
    const moreThanOneValue = spreadsheet.dataSet.moreThanOneValue();
    const hierarchy = new hierarchy_1.Hierarchy();
    const fields = isRowHeader ? rows : columns;
    const isCustomTreeFields = spreadsheet.isCustomHeaderFields(isRowHeader ? 'rows' : 'columns');
    const headerParams = {
        isValueInCols,
        moreThanOneValue,
        rootNode: hierarchy.rootNode,
        hierarchy,
        spreadsheet,
        fields,
        isRowHeader,
        isCustomTreeFields,
    };
    if (isRowHeader) {
        handleRowHeaderHierarchy(headerParams);
    }
    else {
        handleColHeaderHierarchy(headerParams);
    }
    const getLeafNodes = () => {
        if (!isRowHeader) {
            return hierarchy.getLeaves();
        }
        return spreadsheet.isHierarchyTreeType()
            ? hierarchy.getNodes()
            : hierarchy.getLeaves();
    };
    return {
        hierarchy,
        leafNodes: getLeafNodes(),
    };
};
exports.buildHeaderHierarchy = buildHeaderHierarchy;
//# sourceMappingURL=build-header-hierarchy.js.map