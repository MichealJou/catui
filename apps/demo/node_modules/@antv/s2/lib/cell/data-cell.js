"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataCell = void 0;
const lodash_1 = require("lodash");
const base_cell_1 = require("../cell/base-cell");
const common_1 = require("../common");
const basic_1 = require("../common/constant/basic");
const interaction_1 = require("../common/constant/interaction");
const interface_1 = require("../common/interface");
const cell_data_1 = require("../data-set/cell-data");
const cell_1 = require("../utils/cell/cell");
const data_cell_1 = require("../utils/cell/data-cell");
const header_cell_1 = require("../utils/cell/header-cell");
const condition_1 = require("../utils/condition/condition");
const g_mini_charts_1 = require("../utils/g-mini-charts");
const g_renders_1 = require("../utils/g-renders");
/**
 * DataCell for panelGroup area
 * ----------------------------
 * |                  |       |
 * |interval      text| icon  |
 * |                  |       |
 * ----------------------------
 * There are four conditions({@see BaseCell.conditions}) to determine how to render
 * 1、background color
 * 2、icon align in right with size {@link ICON_SIZE}
 * 3、left rect area is interval(in left) and text(in right)
 */
class DataCell extends base_cell_1.BaseCell {
    get cellType() {
        return interaction_1.CellType.DATA_CELL;
    }
    isShallowRender() {
        return super.isShallowRender() || this.meta.shallowRender || false;
    }
    isMultiData() {
        const fieldValue = this.getFieldValue();
        return (0, lodash_1.isObject)(fieldValue);
    }
    getBorderPositions() {
        return [interface_1.CellBorderPosition.BOTTOM, interface_1.CellBorderPosition.RIGHT];
    }
    getValueRange() {
        return this.spreadsheet.dataSet.getValueRangeByField(this.meta.valueField);
    }
    handleByStateName(cells, stateName) {
        if ((0, data_cell_1.includeCell)(cells, this)) {
            this.updateByState(stateName);
        }
    }
    handleSearchResult(cells) {
        if (!(0, data_cell_1.includeCell)(cells, this)) {
            return;
        }
        const targetCell = (0, lodash_1.find)(cells, (cell) => cell === null || cell === void 0 ? void 0 : cell['isTarget']);
        if (targetCell.id === this.getMeta().id) {
            this.updateByState(interaction_1.InteractionStateName.HIGHLIGHT);
        }
        else {
            this.updateByState(interaction_1.InteractionStateName.SEARCH_RESULT);
        }
    }
    handleSelect(cells) {
        var _a, _b;
        const currentCellType = (_a = cells === null || cells === void 0 ? void 0 : cells[0]) === null || _a === void 0 ? void 0 : _a.type;
        switch (currentCellType) {
            // 列多选
            case interaction_1.CellType.COL_CELL:
                this.changeRowColSelectState('colIndex');
                break;
            // 行多选
            case interaction_1.CellType.ROW_CELL:
                this.changeRowColSelectState('rowIndex');
                break;
            // 单元格单选/多选
            case interaction_1.CellType.DATA_CELL:
                if ((0, data_cell_1.shouldUpdateBySelectedCellsHighlight)(this.spreadsheet)) {
                    (0, data_cell_1.updateBySelectedCellsHighlight)(cells, this, this.spreadsheet);
                }
                else if ((0, data_cell_1.includeCell)(cells, this)) {
                    this.updateByState(interaction_1.InteractionStateName.SELECTED);
                }
                else if ((_b = this.spreadsheet.options.interaction) === null || _b === void 0 ? void 0 : _b.selectedCellsSpotlight) {
                    this.updateByState(interaction_1.InteractionStateName.UNSELECTED);
                }
                break;
            default:
                break;
        }
    }
    isDisableHover(cellMeta) {
        return cellMeta.type !== interaction_1.CellType.DATA_CELL;
    }
    handleHover(cells) {
        const hoverCellMeta = (0, lodash_1.first)(cells);
        if (this.isDisableHover(hoverCellMeta)) {
            this.hideInteractionShape();
            return;
        }
        const { currentRow, currentCol } = this.spreadsheet.interaction.getHoverHighlight();
        if (currentRow || currentCol) {
            // 如果当前是hover，要绘制出十字交叉的行列样式
            const currentColIndex = this.meta.colIndex;
            const currentRowIndex = this.meta.rowIndex;
            // 当视图内的 cell 行列 index 与 hover 的 cell 一致，绘制hover的十字样式
            if ((currentCol && currentColIndex === (hoverCellMeta === null || hoverCellMeta === void 0 ? void 0 : hoverCellMeta.colIndex)) ||
                (currentRow && currentRowIndex === (hoverCellMeta === null || hoverCellMeta === void 0 ? void 0 : hoverCellMeta.rowIndex))) {
                this.updateByState(interaction_1.InteractionStateName.HOVER);
            }
            else {
                // 当视图内的 cell 行列 index 与 hover 的 cell 不一致，隐藏其他样式
                this.hideInteractionShape();
            }
        }
        const { id, rowIndex, colIndex } = this.getMeta();
        // fix issue: https://github.com/antvis/S2/issues/1781
        if ((0, lodash_1.isEqual)(hoverCellMeta.id, id) &&
            (0, lodash_1.isEqual)(hoverCellMeta.rowIndex, rowIndex) &&
            (0, lodash_1.isEqual)(hoverCellMeta.colIndex, colIndex)) {
            this.updateByState(interaction_1.InteractionStateName.HOVER_FOCUS);
        }
    }
    update() {
        const stateName = this.spreadsheet.interaction.getCurrentStateName();
        if (stateName === interaction_1.InteractionStateName.ALL_SELECTED) {
            this.updateByState(interaction_1.InteractionStateName.SELECTED);
            return;
        }
        // 获取当前 interaction 记录的 Cells 元信息列表，不仅仅是数据单元格，也可能是行头或者列头。
        const cells = this.spreadsheet.interaction.getCells();
        if ((0, lodash_1.isEmpty)(cells) || !stateName) {
            return;
        }
        switch (stateName) {
            case interaction_1.InteractionStateName.SELECTED:
            case interaction_1.InteractionStateName.DATA_CELL_BRUSH_SELECTED:
                this.handleSelect(cells);
                break;
            case interaction_1.InteractionStateName.HOVER_FOCUS:
            case interaction_1.InteractionStateName.HOVER:
                this.handleHover(cells);
                break;
            case interaction_1.InteractionStateName.SEARCH_RESULT:
                this.handleSearchResult(cells);
                break;
            default:
                this.handleByStateName(cells, stateName);
                break;
        }
    }
    setMeta(viewMeta) {
        super.setMeta(viewMeta);
        if (!this.isShallowRender()) {
            this.initCell();
        }
    }
    drawTextShape() {
        super.drawTextShape();
        if (!this.isShallowRender()) {
            this.drawLinkField(this.meta);
        }
    }
    initCell() {
        this.resetTextAndConditionIconShapes();
        this.generateIconConfig();
        this.shouldHideData = !!this.shouldHideRowSubtotalData();
        this.conditionFill = this.getBackgroundConditionFill();
        this.drawBackgroundShape();
        this.drawInteractiveBgShape();
        if (!this.shouldHideData) {
            this.drawConditionIntervalShape();
        }
        if (!this.shouldHideData) {
            this.drawTextOrCustomRenderer();
        }
        else {
            this.afterDrawText();
        }
    }
    afterDrawText() {
        if (!this.shouldHideData) {
            this.drawConditionIconShapes();
        }
        this.drawBorders();
        this.drawInteractiveBorderShape();
        this.update();
    }
    generateIconConfig() {
        // data cell 只包含 condition icon
        // 并且为了保证格式的统一，只要有 condition icon 配置，就提供 icon 的占位，不过 mapping 结果是否为 null
        // 比如在 icon position 为 right 时，如果根据实际的 mappingResult 来决定是否提供 icon 占位，文字本身对齐效果就不太好，
        var _a;
        const iconCondition = this.findFieldCondition((_a = this.conditions) === null || _a === void 0 ? void 0 : _a.icon);
        const iconCfg = iconCondition &&
            iconCondition.mapping &&
            {
                // 此时 name 是什么值都无所谓，因为后面会根据 mappingResult 来决定
                name: '',
                position: (0, condition_1.getIconPosition)(iconCondition),
            };
        this.groupedIcons = (0, header_cell_1.groupIconsByPosition)([], iconCfg);
    }
    getTextStyle() {
        const textOverflowStyle = this.getCellTextWordWrapStyle();
        const { isTotals } = this.meta;
        const { dataCell } = this.theme;
        const textStyle = isTotals ? dataCell === null || dataCell === void 0 ? void 0 : dataCell.bolderText : dataCell === null || dataCell === void 0 ? void 0 : dataCell.text;
        return this.getContainConditionMappingResultTextStyle(Object.assign(Object.assign({}, textOverflowStyle), textStyle));
    }
    drawConditionIntervalShape() {
        this.conditionIntervalShape = (0, g_mini_charts_1.drawInterval)(this);
    }
    shouldHideRowSubtotalData() {
        var _a, _b;
        if (!this.spreadsheet.isHierarchyTreeType()) {
            return false;
        }
        const { rowId, rowIndex } = this.meta;
        // 如果该格子是被下钻的格子，下钻格子本身来说是明细格子，因为下钻变成了小计格子，是应该展示的
        const drillDownIdPathMap = this.spreadsheet.store.get('drillDownIdPathMap');
        if (drillDownIdPathMap === null || drillDownIdPathMap === void 0 ? void 0 : drillDownIdPathMap.has(rowId)) {
            return false;
        }
        const { row = {} } = (_a = this.spreadsheet.options.totals) !== null && _a !== void 0 ? _a : {};
        const node = (_b = this.spreadsheet.facet) === null || _b === void 0 ? void 0 : _b.getRowLeafNodeByIndex(rowIndex);
        const isRowSubTotal = !(node === null || node === void 0 ? void 0 : node.isGrandTotals) && (node === null || node === void 0 ? void 0 : node.isTotals);
        /**
         * 在树状结构时，如果单元格本身是行小计，但是行小计配置又未开启时
         * 不管能否查到实际的数据，都不应该展示
         */
        return !row.showSubTotals && isRowSubTotal;
    }
    getFormattedFieldValue() {
        var _a;
        if (this.shouldHideData) {
            return {
                value: null,
                /**
                 * 这里使用默认的 placeholder，而不是空字符串，是为了防止后续使用用户自定义的 placeholder
                 * 比如用户自定义 placeholder 为 0, 那行小计也会显示0，也很有迷惑性，显示 - 更为合理
                 */
                formattedValue: basic_1.EMPTY_PLACEHOLDER,
            };
        }
        const { rowId, valueField, fieldValue, data, id } = this.meta;
        const displayFormattedValue = (_a = this.spreadsheet.dataSet.displayFormattedValueMap) === null || _a === void 0 ? void 0 : _a.get(id);
        const rowMeta = this.spreadsheet.dataSet.getFieldMeta(rowId);
        const fieldId = rowMeta ? rowId : valueField;
        const formatter = this.spreadsheet.dataSet.getFieldFormatter(fieldId);
        const formattedValue = displayFormattedValue !== null && displayFormattedValue !== void 0 ? displayFormattedValue : formatter(fieldValue, data, this.meta);
        return {
            value: fieldValue,
            formattedValue,
        };
    }
    getMaxTextWidth() {
        const { width } = this.getBBoxByType(interface_1.CellClipBox.CONTENT_BOX);
        return width - this.getActionAndConditionIconWidth();
    }
    getContentPosition({ contentWidth = this.getActualTextWidth(), } = {}) {
        const contentBox = this.getBBoxByType(interface_1.CellClipBox.CONTENT_BOX);
        const textStyle = this.getTextStyle();
        const iconStyle = this.getIconStyle();
        const { textX, leftIconX, rightIconX } = (0, cell_1.getHorizontalTextIconPosition)({
            bbox: contentBox,
            iconStyle,
            textWidth: contentWidth,
            textAlign: textStyle.textAlign,
            groupedIcons: this.groupedIcons,
            isCustomRenderer: !!this.getRenderer(),
        });
        const y = (0, cell_1.getVerticalTextPosition)(contentBox, textStyle.textBaseline);
        const iconY = (0, cell_1.getVerticalIconPosition)(iconStyle.size, y, textStyle.fontSize, textStyle.textBaseline);
        this.iconPosition = {
            x: !(0, lodash_1.isEmpty)(this.groupedIcons.left) ? leftIconX : rightIconX,
            y: iconY,
        };
        return {
            x: textX,
            y,
        };
    }
    getTextPosition() {
        return this.getContentPosition();
    }
    getIconPosition() {
        return this.iconPosition;
    }
    getBackgroundColor() {
        const backgroundColorByCross = this.getCrossBackgroundColor(this.meta.rowIndex);
        const backgroundColor = backgroundColorByCross.backgroundColor;
        const backgroundColorOpacity = backgroundColorByCross.backgroundColorOpacity;
        if (this.shouldHideData) {
            return {
                backgroundColor,
                backgroundColorOpacity,
                intelligentReverseTextColor: false,
            };
        }
        return (0, lodash_1.merge)({ backgroundColor, backgroundColorOpacity }, this.conditionFill);
    }
    // dataCell 根据 state 改变当前样式，
    changeRowColSelectState(indexType) {
        var _a, _b, _c;
        const { interaction } = this.spreadsheet;
        const currentIndex = (0, lodash_1.get)(this.meta, indexType);
        const { nodes = [], cells = [] } = interaction.getState();
        let isEqualIndex = false;
        // 明细表模式多级表头计算索引换一种策略
        if (this.spreadsheet.isTableMode() && nodes.length) {
            const leafs = ((_b = (_a = nodes[0]) === null || _a === void 0 ? void 0 : _a.hierarchy) === null || _b === void 0 ? void 0 : _b.getLeaves()) || [];
            isEqualIndex = leafs.some((cell, i) => {
                if (nodes.some((node) => node === cell)) {
                    return i === currentIndex;
                }
                return false;
            });
        }
        else {
            isEqualIndex = [...nodes, ...cells].some((cell) => (0, lodash_1.get)(cell, indexType) === currentIndex);
        }
        if (isEqualIndex) {
            this.updateByState(interaction_1.InteractionStateName.SELECTED);
        }
        else if ((_c = this.spreadsheet.options.interaction) === null || _c === void 0 ? void 0 : _c.selectedCellsSpotlight) {
            this.updateByState(interaction_1.InteractionStateName.UNSELECTED);
        }
        else {
            this.hideInteractionShape();
        }
    }
    drawBorders() {
        if (!this.meta['isFrozenCorner']) {
            return;
        }
        base_cell_1.BaseCell.prototype.drawBorders.call(this);
    }
    /**
     * Find current field related condition
     * @param conditions
     */
    findFieldCondition(conditions = []) {
        return (0, condition_1.findFieldCondition)(conditions, this.meta.valueField);
    }
    /**
     * Mapping value to get condition related attrs
     * @param condition
     */
    mappingValue(condition) {
        var _a;
        const value = this.meta.fieldValue;
        const rowDataInfo = this.spreadsheet.isTableMode()
            ? this.spreadsheet.dataSet.getCellData({
                query: { rowIndex: this.meta.rowIndex },
            })
            : cell_data_1.CellData.getFieldValue(this.meta.data);
        return (_a = condition.mapping) === null || _a === void 0 ? void 0 : _a.call(condition, value, rowDataInfo, this);
    }
    updateByState(stateName) {
        super.updateByState(stateName, this);
        if (stateName === interaction_1.InteractionStateName.UNSELECTED) {
            const interactionStateTheme = (0, lodash_1.get)(this.theme, `${this.cellType}.cell.interactionState.${stateName}`);
            if (interactionStateTheme) {
                this.toggleConditionIntervalShapeOpacity(interactionStateTheme.opacity);
            }
        }
    }
    clearUnselectedState() {
        super.clearUnselectedState();
        this.toggleConditionIntervalShapeOpacity(1);
    }
    toggleConditionIntervalShapeOpacity(opacity) {
        (0, g_renders_1.updateShapeAttr)(this.conditionIntervalShape, interaction_1.SHAPE_STYLE_MAP.backgroundOpacity, opacity);
        (0, g_renders_1.updateShapeAttr)(this.conditionIconShapes, interaction_1.SHAPE_STYLE_MAP.opacity, opacity);
    }
    getResizedTextMaxLines() {
        var _a, _b, _c, _d, _e;
        const { rowCell } = this.spreadsheet.options.style;
        // 数值和行高保持一致, 同时兼容明细表
        return ((_d = (_b = (_a = rowCell === null || rowCell === void 0 ? void 0 : rowCell.maxLinesByField) === null || _a === void 0 ? void 0 : _a[this.meta.id]) !== null && _b !== void 0 ? _b : (_c = rowCell === null || rowCell === void 0 ? void 0 : rowCell.maxLinesByField) === null || _c === void 0 ? void 0 : _c[this.meta.rowId]) !== null && _d !== void 0 ? _d : this.getMaxLinesByCustomHeight({
            isCustomHeight: this.meta.height !== ((_e = common_1.DEFAULT_STYLE.dataCell) === null || _e === void 0 ? void 0 : _e.height),
        }));
    }
    getMetaField() {
        return this.meta.valueField;
    }
}
exports.DataCell = DataCell;
//# sourceMappingURL=data-cell.js.map