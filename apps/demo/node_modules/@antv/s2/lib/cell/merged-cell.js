"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MergedCell = void 0;
const lodash_1 = require("lodash");
const constant_1 = require("../common/constant");
const interface_1 = require("../common/interface");
const cell_1 = require("../utils/cell/cell");
const merged_cell_1 = require("../utils/cell/merged-cell");
const g_renders_1 = require("../utils/g-renders");
const text_1 = require("../utils/text");
const data_cell_1 = require("./data-cell");
/**
 * Cell for panelGroup area
 */
class MergedCell extends data_cell_1.DataCell {
    get cellType() {
        return constant_1.CellType.MERGED_CELL;
    }
    constructor(spreadsheet, cells, meta) {
        super(meta, spreadsheet, cells);
    }
    handleRestOptions(...[cells]) {
        this.cells = cells;
    }
    update() { }
    initCell() {
        this.resetTextAndConditionIconShapes();
        // TODO：1、交互态扩展； 2、合并后的单元格文字布局及文字内容（目前参考Excel合并后只保留第一个单元格子的数据）
        this.drawBackgroundShape();
        this.drawTextOrCustomRenderer();
    }
    afterDrawText() {
        this.drawBorders();
    }
    /**
     * Draw merged cells background
     */
    drawBackgroundShape() {
        const allPoints = (0, merged_cell_1.getPolygonPoints)(this.cells);
        const cellTheme = this.theme.dataCell.cell;
        this.backgroundShape = (0, g_renders_1.renderPolygon)(this, {
            points: allPoints,
            fill: cellTheme.backgroundColor,
        });
    }
    drawTextShape() {
        if ((0, lodash_1.isEmpty)(this.meta)) {
            return;
        }
        if (this.isMultiData()) {
            return (0, text_1.drawCustomContent)(this);
        }
        super.drawTextShape();
    }
    drawBorders() {
        const { right, bottom, bottomRightCornerCell } = (0, merged_cell_1.getRightAndBottomCells)(this.cells);
        right.forEach((cell) => {
            var _a;
            const { position, style } = (0, cell_1.getBorderPositionAndStyle)(interface_1.CellBorderPosition.RIGHT, cell.getBBoxByType(), (_a = cell.getStyle()) === null || _a === void 0 ? void 0 : _a.cell);
            (0, g_renders_1.renderLine)(this, Object.assign(Object.assign({}, position), style));
        });
        bottom.forEach((cell) => {
            var _a;
            const { position, style } = (0, cell_1.getBorderPositionAndStyle)(interface_1.CellBorderPosition.BOTTOM, cell.getBBoxByType(), (_a = cell.getStyle()) === null || _a === void 0 ? void 0 : _a.cell);
            (0, g_renders_1.renderLine)(this, Object.assign(Object.assign({}, position), style));
        });
        bottomRightCornerCell.forEach((cell) => {
            var _a;
            const { x, y, width, height } = cell.getBBoxByType();
            const { horizontalBorderWidth = 0, verticalBorderWidth = 0, verticalBorderColor, } = (_a = cell.getStyle()) === null || _a === void 0 ? void 0 : _a.cell;
            const x1 = x + width - verticalBorderWidth / 2;
            const x2 = x1;
            const y1 = y + height - horizontalBorderWidth;
            const y2 = y + height;
            (0, g_renders_1.renderLine)(this, {
                x1,
                x2,
                y1,
                y2,
                lineWidth: verticalBorderWidth,
                stroke: verticalBorderColor,
                strokeOpacity: verticalBorderWidth,
            });
        });
    }
}
exports.MergedCell = MergedCell;
//# sourceMappingURL=merged-cell.js.map