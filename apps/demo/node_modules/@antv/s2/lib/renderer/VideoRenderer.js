"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VideoRenderer = void 0;
const tslib_1 = require("tslib");
// 视频渲染器
const g_1 = require("@antv/g");
const icons_1 = require("../common/icons");
const BaseRenderer_1 = require("./BaseRenderer");
const defaultVideoConfig = {
    loop: true,
    autoplay: true,
    crossOrigin: true,
    controls: false,
    muted: true,
};
class VideoRenderer extends BaseRenderer_1.BaseRenderer {
    prepare(renderer, cell) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const text = yield this.prepareText(renderer, cell);
            return new Promise((resolve) => {
                const { height, width } = this.getCellInfo(cell);
                const { timeout = 10000, fallback = '' } = renderer;
                if (BaseRenderer_1.BaseRenderer.mediaCache.has(text)) {
                    const video = BaseRenderer_1.BaseRenderer.mediaCache.get(text);
                    resolve(video);
                    return;
                }
                const video = document.createElement('video');
                const fallbackTimer = setTimeout(() => {
                    resolve(fallback);
                }, timeout);
                const config = Object.assign(Object.assign({ height,
                    width, src: text }, defaultVideoConfig), renderer.videoConfig);
                Object.assign(video, config);
                video.onloadeddata = () => {
                    clearTimeout(fallbackTimer);
                    BaseRenderer_1.BaseRenderer.mediaCache.set(text, video);
                    resolve(video);
                };
                const onError = () => {
                    clearTimeout(fallbackTimer);
                    resolve(fallback);
                };
                // 错误处理
                ['error', 'abort', 'stalled'].forEach((eventName) => {
                    video.addEventListener(eventName, onError);
                });
            });
        });
    }
    generateConfig(renderer, cell, element) {
        const { x, y, width, height } = this.getCellInfo(cell);
        let transform = '';
        if (element instanceof HTMLVideoElement) {
            const scaleX = width / element.videoWidth;
            const scaleY = height / element.videoHeight;
            transform = `scale(${scaleX}, ${scaleY})`;
        }
        // https://g.antv.antgroup.com/api/css/pattern
        return {
            style: Object.assign({ x,
                y,
                width,
                height, fill: {
                    image: element,
                    repetition: 'no-repeat',
                    transform,
                } }, renderer.config),
        };
    }
    render(cell, config) {
        const rect = new g_1.Rect(config);
        const { x, y, width, height } = this.getCellInfo(cell);
        const calcSize = Math.min(width, height) * 0.25;
        rect.appendChild(new icons_1.GuiIcon({
            name: 'Play',
            width: calcSize,
            height: calcSize,
            x: x + width / 2 - calcSize / 2,
            y: y + height / 2 - calcSize / 2,
            pointerEvents: 'none',
            cursor: 'pointer',
        }));
        cell.appendChild(rect);
    }
}
exports.VideoRenderer = VideoRenderer;
//# sourceMappingURL=VideoRenderer.js.map