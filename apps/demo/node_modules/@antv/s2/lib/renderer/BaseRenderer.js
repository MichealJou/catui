"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseRenderer = void 0;
const tslib_1 = require("tslib");
const g_1 = require("@antv/g");
const interface_1 = require("../common/interface");
const customRenderer_1 = require("../utils/cell/customRenderer");
class BaseRenderer {
    getLoading(cell) {
        var _a;
        const { x, y, height, width } = this.getCellInfo(cell);
        const r = Math.min(height, width) * 0.25;
        const centerX = x + width / 2;
        const centerY = y + height / 2;
        const loadingLine = new g_1.Path({
            style: {
                d: `M${centerX} ${centerY - r}
           A${r} ${r} 0 0 1 ${centerX + r} ${centerY}`,
                stroke: (_a = cell.getIconStyle()) === null || _a === void 0 ? void 0 : _a.fill,
                transformOrigin: `${centerX} ${centerY}`,
            },
        });
        cell.appendChild(loadingLine);
        setTimeout(() => {
            loadingLine.animate([{ transform: 'rotate(0)' }, { transform: 'rotate(360deg)' }], {
                duration: 1000,
                iterations: Infinity,
            });
        });
        return loadingLine;
    }
    process(renderer, cell) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const loadingLine = this.getLoading(cell);
            const element = yield this.prepare(renderer, cell);
            const config = this.generateConfig(renderer, cell, element);
            cell.removeChild(loadingLine);
            loadingLine.destroy();
            this.render(cell, config);
        });
    }
    destroy() { }
    getCellInfo(cell) {
        var _a;
        const fieldValue = cell.getFieldValue();
        const text = (_a = fieldValue === null || fieldValue === void 0 ? void 0 : fieldValue.toString()) !== null && _a !== void 0 ? _a : '';
        return Object.assign({ text }, cell.getBBoxByType(interface_1.CellClipBox.CONTENT_BOX));
    }
    prepareText(renderer, cell) {
        const { text } = this.getCellInfo(cell);
        return (0, customRenderer_1.getPreparedText)(renderer.prepareText, text);
    }
}
exports.BaseRenderer = BaseRenderer;
BaseRenderer.mediaCache = new Map();
//# sourceMappingURL=BaseRenderer.js.map