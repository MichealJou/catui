import { EXTRA_FIELD, PivotSheet, ResizeType, setupDataConfig, setupOptions, } from '@antv/s2';
import { last } from 'lodash';
import { PivotChartDataCell } from './cell/pivot-chart-data-cell';
import { DEFAULT_COL_AXIS_SIZE, DEFAULT_DIMENSION_SIZE, DEFAULT_MEASURE_SIZE, DEFAULT_OPTIONS, DEFAULT_ROW_AXIS_SIZE, FIXED_DATA_CONFIG, FIXED_OPTIONS, } from './constant';
import { PivotChartFacet } from './facet/pivot-chart-facet';
import { RootInteraction } from './interaction/root';
import { getCustomTheme as defaultGetCustomTheme } from './utils/theme';
export class PivotChartSheet extends PivotSheet {
    initInteraction() {
        var _a, _b;
        (_b = (_a = this.interaction) === null || _a === void 0 ? void 0 : _a.destroy) === null || _b === void 0 ? void 0 : _b.call(_a);
        this.interaction = new RootInteraction(this);
    }
    setupDataConfig(dataCfg) {
        this.dataCfg = setupDataConfig(dataCfg, FIXED_DATA_CONFIG);
    }
    setupOptions(options) {
        this.options = setupOptions(DEFAULT_OPTIONS, this.getRuntimeDefaultOptions(options), options, this.getRuntimeFixedOptions(), FIXED_OPTIONS);
    }
    setThemeCfg(themeCfg = {}, getCustomTheme = defaultGetCustomTheme) {
        super.setThemeCfg(themeCfg, getCustomTheme);
    }
    buildFacet() {
        var _a, _b, _c, _d, _e;
        var _f;
        if (this.isCustomRowFields() || this.isCustomColumnFields()) {
            super.buildFacet();
            return;
        }
        const defaultCell = (viewMeta) => new PivotChartDataCell(viewMeta, this);
        (_a = (_f = this.options).dataCell) !== null && _a !== void 0 ? _a : (_f.dataCell = defaultCell);
        (_b = this.facet) === null || _b === void 0 ? void 0 : _b.destroy();
        this.facet = (_e = (_d = (_c = this.options).facet) === null || _d === void 0 ? void 0 : _d.call(_c, this)) !== null && _e !== void 0 ? _e : new PivotChartFacet(this);
        this.facet.render();
    }
    getRuntimeDefaultOptions(options) {
        var _a;
        const { rows = [], columns = [], valueInCols = true, } = (_a = this.dataCfg.fields) !== null && _a !== void 0 ? _a : {};
        /**
         * 下面的逻辑准则：
         *    如果是笛卡尔坐标系，希望 x 轴 dimension 的每个维度默认宽度大致相同，y 轴 measure 的宽度始终保持都相同
         *      比如对于 rows: province-> city , value: number 来说
         *         四川下面有 n 个城市，北京下面有 m 个城市，那么四川的宽度是 n * width, 北京的宽度是 m * width
         *         而不管是四川，还是北京， y 轴展示的都是 number 的值，那么 y 轴的宽度保持相同，能快速通过图形的尺寸看出数据的相对大小。
         *    如果是极坐标系， 希望 x 轴宽度相同，y 轴 measure 的宽度也都相同
         *         比如对于 rows: province-> city , value: number 来说
         *         四川下面有 n 个城市，北京下面有 m 个城市，那么四川的宽度是 width, 北京的宽度也是 width，不再以维度数量作为依据，能让数据的呈现效果更好
         */
        const isPolar = this.isPolarCoordinate(options);
        if (valueInCols) {
            const lastRow = last(rows);
            return {
                style: {
                    rowCell: {
                        widthByField: {
                            [lastRow]: DEFAULT_ROW_AXIS_SIZE,
                        },
                    },
                    colCell: {
                        heightByField: {
                            [EXTRA_FIELD]: DEFAULT_COL_AXIS_SIZE,
                        },
                    },
                    dataCell: {
                        width: DEFAULT_MEASURE_SIZE,
                        height: isPolar ? DEFAULT_MEASURE_SIZE : DEFAULT_DIMENSION_SIZE,
                    },
                },
            };
        }
        const lastCol = last(columns);
        return {
            style: {
                rowCell: {
                    widthByField: {
                        [EXTRA_FIELD]: DEFAULT_ROW_AXIS_SIZE,
                    },
                },
                colCell: {
                    heightByField: {
                        [lastCol]: DEFAULT_COL_AXIS_SIZE,
                    },
                },
                dataCell: {
                    width: isPolar ? DEFAULT_MEASURE_SIZE : DEFAULT_DIMENSION_SIZE,
                    height: DEFAULT_MEASURE_SIZE,
                },
            },
        };
    }
    getRuntimeFixedOptions() {
        var _a;
        const { valueInCols = true } = (_a = this.dataCfg.fields) !== null && _a !== void 0 ? _a : {};
        if (valueInCols) {
            return {
                interaction: {
                    resize: {
                        rowResizeType: ResizeType.CURRENT,
                        colResizeType: ResizeType.ALL,
                    },
                },
            };
        }
        return {
            interaction: {
                resize: {
                    rowResizeType: ResizeType.ALL,
                    colResizeType: ResizeType.CURRENT,
                },
            },
        };
    }
    isPolarCoordinate(options = this.options) {
        var _a;
        return ((_a = options === null || options === void 0 ? void 0 : options.chart) === null || _a === void 0 ? void 0 : _a.coordinate) === 'polar';
    }
    enableAsyncExport() {
        return new Error("pivot chart doesn't support export all data");
    }
}
//# sourceMappingURL=pivot-chart-sheet.js.map