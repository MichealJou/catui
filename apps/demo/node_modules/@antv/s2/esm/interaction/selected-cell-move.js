import { CellType, FrozenGroupArea, InteractionName, InteractionStateName, } from '../common';
import { InteractionKeyboardKey, S2Event } from '../common/constant';
import { getDataCellId } from '../utils';
import { getRangeIndex } from '../utils/interaction/select-event';
import { BaseEvent } from './base-interaction';
const SelectedCellMoveMap = [
    InteractionKeyboardKey.ARROW_LEFT,
    InteractionKeyboardKey.ARROW_RIGHT,
    InteractionKeyboardKey.ARROW_UP,
    InteractionKeyboardKey.ARROW_DOWN,
];
export class SelectedCellMove extends BaseEvent {
    constructor(spreadsheet) {
        super(spreadsheet);
    }
    isCanvasEffect() {
        return this.spreadsheet.interaction.eventController.isCanvasEffect;
    }
    bindEvents() {
        this.spreadsheet.on(S2Event.GLOBAL_KEYBOARD_DOWN, (event) => {
            if (!this.isCanvasEffect()) {
                return;
            }
            const isShift = event.shiftKey;
            const isMeta = event.metaKey;
            const hasDirection = SelectedCellMoveMap.includes(event.key);
            let changeStartCell = false;
            let isJumpMode = false;
            let isSingleSelection = false;
            if (hasDirection) {
                if (isMeta && isShift) {
                    // META + SHIFT + Direction
                    changeStartCell = false;
                    isJumpMode = true;
                    isSingleSelection = false;
                }
                else if (isMeta) {
                    // META + Direction
                    changeStartCell = true;
                    isJumpMode = true;
                    isSingleSelection = true;
                }
                else if (isShift) {
                    // SHIFT + Direction
                    changeStartCell = false;
                    isJumpMode = false;
                    isSingleSelection = false;
                }
                else {
                    // Only Direction
                    changeStartCell = true;
                    isJumpMode = false;
                    isSingleSelection = true;
                }
                this.handleMove({
                    event,
                    changeStartCell,
                    isJumpMode,
                    isSingleSelection,
                });
            }
        });
        this.spreadsheet.on(S2Event.DATA_CELL_CLICK, (event) => {
            const cell = this.spreadsheet.getCell(event.target);
            const cellMeta = cell === null || cell === void 0 ? void 0 : cell.getMeta();
            if (cellMeta) {
                this.startCell = this.getCellMetaByViewMeta(cellMeta);
                this.endCell = this.startCell;
            }
        });
    }
    getCellMetaByViewMeta(meta) {
        return {
            rowIndex: meta.rowIndex,
            colIndex: meta.colIndex,
            id: meta.id,
            type: CellType.DATA_CELL,
        };
    }
    // core move function
    handleMove({ event, changeStartCell, isJumpMode, isSingleSelection, }) {
        const { spreadsheet, startCell, endCell } = this;
        const cell = changeStartCell ? startCell : endCell;
        const rowCol = this.getMoveInfo(event.key, cell, isJumpMode);
        if (!rowCol) {
            return;
        }
        const [rowIndex, colIndex] = [rowCol.row, rowCol.col];
        this.scrollToActiveCell(spreadsheet, rowIndex, colIndex);
        const movedCell = this.generateCellMeta(spreadsheet, rowIndex, colIndex);
        const selectedCells = isSingleSelection
            ? [movedCell]
            : this.getRangeCells(spreadsheet, startCell, movedCell);
        if (changeStartCell) {
            this.startCell = movedCell;
        }
        this.endCell = movedCell;
        spreadsheet.interaction.changeState({
            stateName: InteractionStateName.SELECTED,
            cells: selectedCells,
        });
        spreadsheet.interaction.emitSelectEvent({
            event,
            interactionName: InteractionName.SELECTED_CELL_MOVE,
        });
        this.spreadsheet.emit(S2Event.DATA_CELL_SELECT_MOVE, selectedCells);
    }
    generateCellMeta(spreadsheet, row, col) {
        const { isTableMode, facet } = spreadsheet;
        const rowLeafNodes = facet.getRowLeafNodes();
        const colLeafNodes = facet.getColLeafNodes();
        const rowId = isTableMode() ? String(row) : rowLeafNodes[row].id;
        const colId = colLeafNodes[col].id;
        return {
            rowIndex: row,
            colIndex: col,
            id: getDataCellId(rowId, colId),
            type: CellType.DATA_CELL,
        };
    }
    getRangeCells(spreadsheet, startCell, endCell) {
        const { start: { rowIndex: startRowIndex, colIndex: startColIndex }, end: { rowIndex: endRowIndex, colIndex: endColIndex }, } = getRangeIndex(startCell, endCell);
        const cells = [];
        for (let row = startRowIndex; row <= endRowIndex; row++) {
            for (let col = startColIndex; col <= endColIndex; col++) {
                cells.push(this.generateCellMeta(spreadsheet, row, col));
            }
        }
        return cells;
    }
    getMoveInfo(code, cell, isJump) {
        const { spreadsheet } = this;
        const { rowCount, trailingRowCount, colCount, trailingColCount } = spreadsheet.facet.getFrozenOptions();
        const { start, end } = spreadsheet.facet.getCellRange();
        const colLeafNodes = spreadsheet.facet.getColLeafNodes();
        const [minCol, maxCol] = [
            0 + colCount,
            colLeafNodes.length - trailingColCount - 1,
        ];
        const [minRow, maxRow] = [start + rowCount, end - trailingRowCount];
        if (!cell) {
            return;
        }
        switch (code) {
            case InteractionKeyboardKey.ARROW_RIGHT:
                if (cell.colIndex + 1 > maxCol) {
                    return;
                }
                return {
                    row: cell.rowIndex,
                    col: isJump ? maxCol : cell.colIndex + 1,
                };
            case InteractionKeyboardKey.ARROW_LEFT:
                if (cell.colIndex - 1 < minCol) {
                    return;
                }
                return {
                    row: cell.rowIndex,
                    col: isJump ? minCol : cell.colIndex - 1,
                };
            case InteractionKeyboardKey.ARROW_UP:
                if (cell.rowIndex - 1 < minRow) {
                    return;
                }
                return {
                    row: isJump ? minRow : cell.rowIndex - 1,
                    col: cell.colIndex,
                };
            case InteractionKeyboardKey.ARROW_DOWN:
                if (cell.rowIndex + 1 > maxRow) {
                    return;
                }
                return {
                    row: isJump ? maxRow : cell.rowIndex + 1,
                    col: cell.colIndex,
                };
            default:
                break;
        }
    }
    // 计算需要滚动的offset
    calculateOffset(spreadsheet, rowIndex, colIndex) {
        const facet = spreadsheet.facet;
        const { rowCount } = facet.getFrozenOptions();
        const colLeafNodes = facet.getColLeafNodes();
        const { viewportHeight: height, viewportWidth: width } = facet.panelBBox;
        const frozenGroupAreas = facet.frozenGroupAreas;
        const frozenColWidth = frozenGroupAreas[FrozenGroupArea.Col].width;
        const frozenTrailingColWidth = frozenGroupAreas[FrozenGroupArea.TrailingCol].width;
        const frozenTrailingRowHeight = frozenGroupAreas[FrozenGroupArea.TrailingRow].height;
        const indexes = facet.panelScrollGroupIndexes;
        const targetNode = colLeafNodes.find((node) => node.colIndex === colIndex);
        let offsetX = null;
        let offsetY = null;
        // offsetX
        if (colIndex <= indexes[0]) {
            // scroll left
            offsetX = (targetNode === null || targetNode === void 0 ? void 0 : targetNode.x) - frozenColWidth;
        }
        else if (colIndex >= indexes[1]) {
            // scroll right
            offsetX =
                (targetNode === null || targetNode === void 0 ? void 0 : targetNode.x) + (targetNode === null || targetNode === void 0 ? void 0 : targetNode.width) - width + frozenTrailingColWidth;
        }
        // offsetY
        if (rowIndex <= indexes[2]) {
            // scroll top
            offsetY = facet.viewCellHeights.getCellOffsetY(rowIndex - rowCount);
        }
        else if (rowIndex >= indexes[3]) {
            // scroll bottom
            const y = facet.viewCellHeights.getCellOffsetY(rowIndex + 1);
            offsetY = y - height + frozenTrailingRowHeight;
        }
        return { offsetX, offsetY };
    }
    scrollToActiveCell(spreadsheet, rowIndex, colIndex) {
        const { offsetX, offsetY } = this.calculateOffset(spreadsheet, rowIndex, colIndex);
        const { facet } = spreadsheet;
        const { scrollX, scrollY } = spreadsheet.facet.getScrollOffset();
        facet.scrollWithAnimation({
            offsetX: { value: offsetX !== null && offsetX !== void 0 ? offsetX : scrollX },
            offsetY: { value: offsetY !== null && offsetY !== void 0 ? offsetY : scrollY },
        });
    }
}
//# sourceMappingURL=selected-cell-move.js.map