import { isNil, last, map } from 'lodash';
import { InterceptType, S2Event } from '../../common/constant';
import { InteractionBrushSelectionStage, InteractionName, InteractionStateName, ScrollDirection, } from '../../common/constant/interaction';
import { getCellMeta } from '../../utils/interaction/select-event';
import { BaseBrushSelection } from './base-brush-selection';
export class RowCellBrushSelection extends BaseBrushSelection {
    constructor() {
        super(...arguments);
        this.displayedCells = [];
        this.brushRangeCells = [];
        this.isInBrushRange = (meta) => {
            // startã€end éƒ½æ˜¯ç›¸å¯¹ä½ç½®
            const { start, end } = this.getBrushRange();
            const { scrollY, rowHeaderScrollX } = this.spreadsheet.facet.getScrollOffset();
            const { cornerBBox } = this.spreadsheet.facet;
            // ç»å¯¹ä½ç½®ï¼Œä¸éšæ»šåŠ¨æ¡å˜åŒ–
            const { x = 0, y = 0, width = 0, height = 0 } = meta;
            return this.rectanglesIntersect({
                // è¡Œå¤´è¿‡é•¿æ—¶ï¼Œå¯ä»¥å•ç‹¬è¿›è¡Œæ»šåŠ¨ï¼Œæ‰€ä»¥éœ€è¦åŠ ä¸Šæ»šåŠ¨çš„è·ç¦»
                minX: start.x + rowHeaderScrollX,
                // ç”±äºŽåˆ·é€‰çš„æ—¶å€™ï¼Œæ˜¯ä»¥è¡Œå¤´çš„å·¦ä¸Šè§’ä¸ºèµ·ç‚¹ï¼Œæ‰€ä»¥éœ€è¦å‡åŽ»è§’å¤´çš„å®½åº¦ï¼Œåœ¨æ»šåŠ¨åŽéœ€è¦åŠ ä¸Šæ»šåŠ¨æ¡çš„åç§»é‡
                minY: start.y - cornerBBox.height + scrollY,
                maxX: end.x + rowHeaderScrollX,
                maxY: end.y - cornerBBox.height + scrollY,
            }, {
                minX: x,
                maxX: x + width,
                minY: y,
                maxY: y + height,
            });
        };
        this.onUpdateCells = (root) => root.updateCells(this.spreadsheet.facet.getRowCells());
        this.getSelectedRowNodes = () => {
            return this.spreadsheet.facet.getRowNodes().filter(this.isInBrushRange);
        };
        /**
           * è¡Œå¤´çš„éžå¶å­èŠ‚ç‚¹æ»šåŠ¨åˆ·é€‰, ä»¥å½“å‰èŠ‚ç‚¹æ‰€å¯¹åº” [å¯è§†èŒƒå›´] å†…å¶å­èŠ‚ç‚¹ä¸ºåŸºå‡†
           * ä¾‹: å½“å‰åˆ·é€‰ [æµ™æ±Ÿçœ] è¡Œå¤´çš„è¿™ä¸€åˆ—, å‘ ðŸ”½ æ»šåŠ¨ä»¥ [çº¸å¼ ] ä¸ºå‡†, å‘ ðŸ”¼æ»šåŠ¨ä»¥ [æ¡Œå­] ä¸ºå‡†
             ---------------------------------------
           * |       | æ­å·žå¸‚ | å®¶å…·    | ðŸ”¼ [æ¡Œå­]   |
           * |       |       |        | æ²™å‘   |
           * |       |       | åŠžå…¬ç”¨å“ | ç¬”    |
           * |       |       |         | çº¸å¼   |
           * | æµ™æ±Ÿçœ |       |         |      |
           * |       | ç»å…´å¸‚ | å®¶å…·     | æ¡Œå­  |
           * |       |       |         | æ²™å‘  |
           * |       |       | åŠžå…¬ç”¨å“ | ç¬”    |
           * |       |       |         | ðŸ”½ [çº¸å¼ ] |
           * -------------------------------------
           */
        this.getVisibleRowLeafCellByScrollDirection = (dir) => {
            const rowCell = this.spreadsheet.facet.getRowCells();
            if (dir === ScrollDirection.SCROLL_DOWN) {
                return last(rowCell);
            }
            return rowCell.find((cell) => {
                const meta = cell.getMeta();
                return meta.isLeaf;
            });
        };
        this.getWillScrollToRowIndex = (dir) => {
            var _a, _b;
            // è¡Œå¤´å¶å­èŠ‚ç‚¹, æŒ‰é»˜è®¤é€»è¾‘å¤„ç†å³å¯
            if (!isNil(this.endBrushPoint.rowIndex)) {
                return this.getDefaultWillScrollToRowIndex(dir);
            }
            const visibleCell = this.getVisibleRowLeafCellByScrollDirection(dir);
            const lastRowIndex = (_b = (_a = visibleCell === null || visibleCell === void 0 ? void 0 : visibleCell.getMeta()) === null || _a === void 0 ? void 0 : _a.rowIndex) !== null && _b !== void 0 ? _b : 0;
            const nextRowIndex = lastRowIndex + this.getWillScrollRowIndexDiff(dir);
            return this.validateYIndex(nextRowIndex);
        };
    }
    bindMouseDown() {
        this.spreadsheet.on(S2Event.ROW_CELL_MOUSE_DOWN, (event) => {
            if (!this.spreadsheet.interaction.getBrushSelection().rowCell) {
                return;
            }
            super.mouseDown(event);
        });
    }
    isPointInCanvas(point) {
        // èŽ·å–è¡Œå¤´çš„åŒºåŸŸèŒƒå›´
        const { height: maxY } = this.spreadsheet.facet.getCanvasSize();
        const { minX, height: minY, maxX } = this.spreadsheet.facet.cornerBBox;
        return (point.x >= minX && point.x <= maxX && point.y >= minY && point.y <= maxY);
    }
    bindMouseMove() {
        this.spreadsheet.on(S2Event.GLOBAL_MOUSE_MOVE, (event) => {
            if (this.brushSelectionStage === InteractionBrushSelectionStage.UN_DRAGGED) {
                return;
            }
            this.setBrushSelectionStage(InteractionBrushSelectionStage.DRAGGED);
            const pointInCanvas = this.spreadsheet.interaction.eventController.getViewportPoint(event);
            if (this.autoBrushScroll(pointInCanvas, true)) {
                return;
            }
            this.renderPrepareSelected(pointInCanvas);
        });
    }
    setDisplayedCells() {
        this.displayedCells = this.spreadsheet.facet.getRowCells();
    }
    // æœ€ç»ˆåˆ·é€‰çš„ cells
    updateSelectedCells(event) {
        const selectedRowNodes = this.getSelectedRowNodes();
        const scrollBrushRangeCells = this.getScrollBrushRangeCells(selectedRowNodes);
        const selectedCellMetas = map(scrollBrushRangeCells, getCellMeta);
        this.spreadsheet.interaction.changeState({
            cells: selectedCellMetas,
            stateName: InteractionStateName.ROW_CELL_BRUSH_SELECTED,
            onUpdateCells: this.onUpdateCells,
        });
        this.emitBrushSelectionEvent(S2Event.ROW_CELL_BRUSH_SELECTION, scrollBrushRangeCells, {
            event,
            targetCell: scrollBrushRangeCells[0],
            interactionName: InteractionName.ROW_CELL_BRUSH_SELECTION,
        });
    }
    addBrushIntercepts() {
        this.spreadsheet.interaction.addIntercepts([
            InterceptType.ROW_CELL_BRUSH_SELECTION,
        ]);
    }
    getScrollBrushRangeCells(nodes) {
        return nodes.map((node) => {
            const visibleCell = this.getVisibleBrushRangeCells(node.id);
            if (visibleCell) {
                return visibleCell;
            }
            return this.spreadsheet.facet.rowHeader.getCellInstance(node);
        });
    }
    getPrepareSelectMaskPosition(brushRange) {
        const { minY } = this.spreadsheet.facet.panelBBox;
        const x = brushRange.start.x;
        const y = Math.max(brushRange.start.y, minY);
        return {
            x,
            y,
        };
    }
}
//# sourceMappingURL=row-brush-selection.js.map