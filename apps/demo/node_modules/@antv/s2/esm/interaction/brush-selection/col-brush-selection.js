import { map } from 'lodash';
import { InterceptType, S2Event } from '../../common/constant';
import { InteractionBrushSelectionStage, InteractionName, InteractionStateName, } from '../../common/constant/interaction';
import { getCellMeta } from '../../utils/interaction/select-event';
import { BaseBrushSelection } from './base-brush-selection';
export class ColCellBrushSelection extends BaseBrushSelection {
    constructor() {
        super(...arguments);
        this.displayedCells = [];
        this.brushRangeCells = [];
        this.onUpdateCells = (root) => root.updateCells(this.spreadsheet.facet.getColCells());
    }
    bindEvents() {
        this.bindMouseDown();
        this.bindMouseMove();
        this.bindMouseUp();
    }
    bindMouseDown() {
        this.spreadsheet.on(S2Event.COL_CELL_MOUSE_DOWN, (event) => {
            if (!this.spreadsheet.interaction.getBrushSelection().colCell) {
                return;
            }
            super.mouseDown(event);
        });
    }
    isPointInCanvas(point) {
        // 获取列头的区域范围
        const { width: maxX } = this.spreadsheet.facet.getCanvasSize();
        const { width: minX, minY, maxY } = this.spreadsheet.facet.cornerBBox;
        return (point.x >= minX && point.x <= maxX && point.y >= minY && point.y <= maxY);
    }
    bindMouseMove() {
        this.spreadsheet.on(S2Event.COL_CELL_MOUSE_MOVE, (event) => {
            var _a;
            if (this.brushSelectionStage === InteractionBrushSelectionStage.UN_DRAGGED) {
                return;
            }
            this.setBrushSelectionStage(InteractionBrushSelectionStage.DRAGGED);
            const pointInCanvas = (_a = this.spreadsheet.interaction.eventController) === null || _a === void 0 ? void 0 : _a.getViewportPoint(event);
            if (!this.isPointInCanvas(pointInCanvas)) {
                return;
            }
            this.renderPrepareSelected(pointInCanvas);
        });
    }
    setDisplayedCells() {
        this.displayedCells = this.spreadsheet.facet.getColCells();
    }
    /**
     * 用户判断 colCell 是否在当前刷选的范围内
     * @param meta colCell 位置等属性存储的对象
     * @returns boolean
     */
    isInBrushRange(meta) {
        const { start, end } = this.getBrushRange();
        const { scrollX = 0 } = this.spreadsheet.facet.getScrollOffset();
        const cornerBBox = this.spreadsheet.facet.cornerBBox;
        const { x = 0, y = 0, width = 0, height = 0 } = meta;
        return this.rectanglesIntersect({
            // 由于刷选的时候，是以列头的左上角为起点，所以需要减去角头的宽度，在滚动后需要加上滚动条的偏移量
            minX: start.x - cornerBBox.width + scrollX,
            minY: start.y,
            maxX: end.x - cornerBBox.width + scrollX,
            maxY: end.y,
        }, {
            minX: x,
            maxX: x + width,
            minY: y,
            maxY: y + height,
        });
    }
    // 最终刷选的 cell
    updateSelectedCells(event) {
        const { interaction, facet } = this.spreadsheet;
        interaction.changeState({
            cells: map(this.brushRangeCells, getCellMeta),
            onUpdateCells: (root) => {
                root.updateCells(facet.getColCells());
            },
            stateName: InteractionStateName.COL_CELL_BRUSH_SELECTED,
        });
        this.emitBrushSelectionEvent(S2Event.COL_CELL_BRUSH_SELECTION, this.brushRangeCells, {
            event,
            targetCell: this.brushRangeCells[0],
            interactionName: InteractionName.COL_CELL_BRUSH_SELECTION,
        });
    }
    addBrushIntercepts() {
        this.spreadsheet.interaction.addIntercepts([
            InterceptType.COL_CELL_BRUSH_SELECTION,
        ]);
    }
}
//# sourceMappingURL=col-brush-selection.js.map