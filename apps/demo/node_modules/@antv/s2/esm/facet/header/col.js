import { Group } from '@antv/g';
import { each } from 'lodash';
import { ColCell } from '../../cell/col-cell';
import { ColCellPool } from '../../cell/pool';
import { FRONT_GROUND_GROUP_FROZEN_Z_INDEX, FRONT_GROUND_GROUP_SCROLL_Z_INDEX, FrozenGroupArea, KEY_GROUP_COL_FROZEN, KEY_GROUP_COL_FROZEN_TRAILING, KEY_GROUP_COL_SCROLL, S2Event, } from '../../common/constant';
import { translateGroup } from '../utils';
import { BaseHeader } from './base';
import { getExtraFrozenColNodes, getFrozenColOffset, getFrozenTrailingColOffset, getScrollGroupClip, } from './util';
/**
 * Column Header for SpreadSheet
 */
export class ColHeader extends BaseHeader {
    constructor() {
        super(...arguments);
        this.colCellPool = new ColCellPool();
    }
    initGroups() {
        this.scrollGroup = this.appendChild(new Group({
            name: KEY_GROUP_COL_SCROLL,
            style: { zIndex: FRONT_GROUND_GROUP_SCROLL_Z_INDEX },
        }));
        this.frozenGroup = this.appendChild(new Group({
            name: KEY_GROUP_COL_FROZEN,
            style: { zIndex: FRONT_GROUND_GROUP_FROZEN_Z_INDEX },
        }));
        this.frozenTrailingGroup = this.appendChild(new Group({
            name: KEY_GROUP_COL_FROZEN_TRAILING,
            style: { zIndex: FRONT_GROUND_GROUP_FROZEN_Z_INDEX },
        }));
        this.extraFrozenNodes = getExtraFrozenColNodes(this.headerConfig.spreadsheet.facet);
    }
    getCellGroup(node) {
        if (node.isFrozenHead) {
            return this.frozenGroup;
        }
        if (node.isFrozenTrailing) {
            return this.frozenTrailingGroup;
        }
        return this.scrollGroup;
    }
    getCellInstance(node) {
        var _a;
        if (this.colCellPool.pool.length > 0 &&
            ((_a = this.headerConfig.spreadsheet.options.future) === null || _a === void 0 ? void 0 : _a.experimentalReuseCell)) {
            const colCell = this.colCellPool.acquire();
            colCell.reInitCell(node, this.getHeaderConfig());
            return colCell;
        }
        const headerConfig = this.getHeaderConfig();
        const { spreadsheet } = this.getHeaderConfig();
        const { colCell } = spreadsheet.options;
        return ((colCell === null || colCell === void 0 ? void 0 : colCell(node, spreadsheet, headerConfig)) ||
            new ColCell(node, spreadsheet, headerConfig));
    }
    appendNode(node) {
        var _a;
        const { spreadsheet } = this.getHeaderConfig();
        const group = this.getCellGroup(node);
        let cell;
        if (((_a = node.belongsCell) === null || _a === void 0 ? void 0 : _a.parentNode) === group &&
            node.belongsCell.getMeta() === node) {
            cell = node.belongsCell;
            cell.setHeaderConfig(this.headerConfig);
        }
        else {
            cell = this.getCellInstance(node);
            node.belongsCell = cell;
            if (cell.parentElement !== group) {
                group === null || group === void 0 ? void 0 : group.appendChild(cell);
            }
        }
        spreadsheet.emit(S2Event.COL_CELL_RENDER, cell);
        spreadsheet.emit(S2Event.LAYOUT_CELL_RENDER, cell);
    }
    layout() {
        const { nodes } = this.getHeaderConfig();
        each(nodes, (node) => {
            if (this.isColCellInRect(node)) {
                this.appendNode(node);
            }
        });
        each(this.extraFrozenNodes, (node) => {
            this.appendNode(node);
        });
    }
    /**
     * Make colHeader scroll with hScrollBar
     * @param scrollX horizontal offset
     * @param cornerWidth only has real meaning when scroll contains rowCell
     * @param type
     */
    onColScroll(scrollX, type) {
        if (this.headerConfig.scrollX !== scrollX) {
            this.headerConfig.scrollX = scrollX;
            this.render(type);
        }
    }
    clip() {
        const { height, spreadsheet, position, viewportWidth, cornerWidth = 0, scrollX = 0, } = this.getHeaderConfig();
        const facet = spreadsheet.facet;
        const frozenGroupAreas = facet.frozenGroupAreas;
        const frozenColGroupWidth = frozenGroupAreas[FrozenGroupArea.Col].width;
        const frozenTrailingColGroupWidth = frozenGroupAreas[FrozenGroupArea.TrailingCol].width;
        const { x, width } = getScrollGroupClip(facet, position);
        this.createOrUpdate('scrollGroup.style.clipPath', {
            x,
            y: position.y,
            width,
            height,
        });
        this.createOrUpdate('frozenGroup.style.clipPath', {
            x: position.x - getFrozenColOffset(facet, cornerWidth, scrollX),
            y: position.y,
            width: frozenColGroupWidth,
            height,
        });
        this.createOrUpdate('frozenTrailingGroup.style.clipPath', {
            x: position.x + viewportWidth - frozenTrailingColGroupWidth,
            y: position.y,
            width: frozenTrailingColGroupWidth,
            height,
        });
    }
    isColCellInRect(node) {
        const { spreadsheet, cornerWidth = 0, viewportWidth, scrollX = 0, position, } = this.getHeaderConfig();
        const frozenGroupAreas = spreadsheet.facet
            .frozenGroupAreas;
        let leftBoundary;
        const frozenColWidth = frozenGroupAreas[FrozenGroupArea.Col].width;
        const frozenTrailingColWidth = frozenGroupAreas[FrozenGroupArea.TrailingCol].width;
        if (spreadsheet.isFrozenRowHeader()) {
            leftBoundary = frozenColWidth;
        }
        else if (frozenColWidth) {
            // 如果存在列冻结，那么 frame 最多滚动到最左侧，即滚动 cornerWidth 的宽度
            leftBoundary = frozenColWidth - cornerWidth;
        }
        else {
            leftBoundary = -position.x;
        }
        return (
        // don't care about scrollY, because there is only freeze col-header exist
        viewportWidth - frozenTrailingColWidth >= node.x - scrollX &&
            leftBoundary <= node.x + node.width - scrollX);
    }
    offset() {
        const { viewportWidth, scrollX = 0, position, spreadsheet, cornerWidth, } = this.getHeaderConfig();
        translateGroup(this.scrollGroup, position.x - scrollX, position.y);
        const facet = spreadsheet.facet;
        const colOffset = getFrozenColOffset(facet, cornerWidth, scrollX);
        const trailingColOffset = getFrozenTrailingColOffset(facet, viewportWidth);
        translateGroup(this.frozenGroup, position.x - colOffset, position.y);
        translateGroup(this.frozenTrailingGroup, position.x - trailingColOffset, position.y);
    }
    clear() {
        var _a;
        if ((_a = this.headerConfig.spreadsheet.options.future) === null || _a === void 0 ? void 0 : _a.experimentalReuseCell) {
            // @ts-ignore
            this.scrollGroup.childNodes.forEach((colCell) => {
                if (!this.isColCellInRect(colCell.getMeta())) {
                    colCell.getMeta().belongsCell = null;
                    this.colCellPool.release(colCell);
                }
            });
        }
        else {
            super.clear();
        }
    }
    clearResizeAreaGroup() { }
}
//# sourceMappingURL=col.js.map