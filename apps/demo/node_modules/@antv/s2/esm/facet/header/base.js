import { Group } from '@antv/g';
import { createOrUpdateRect } from '../../utils/g-utils';
/**
 * New Base Header for all headers(cornerHeader, rowHeader, colHeader)
 * NOTE: Do not use this.cfg(which lays in group) to get header config,
 * use @see headerConfig instead
 */
export class BaseHeader extends Group {
    constructor(config) {
        super();
        /**
         * Check whether header cell in viewPort
         */
        this.isHeaderCellInViewport = ({ cellPosition, cellSize, viewportPosition, viewportSize, }) => cellPosition + cellSize >= viewportPosition &&
            viewportPosition + viewportSize >= cellPosition;
        this.headerConfig = config;
        this.initGroups();
    }
    getHeaderConfig() {
        return this.headerConfig || {};
    }
    // start render header
    render(type) {
        // clear resize group
        this.clearResizeAreaGroup(type);
        // clear self first
        this.clear();
        // draw by new data
        this.layout();
        // offset group
        this.offset();
        // clip group
        this.clip();
    }
    /**
     * Scroll header group's x,y
     * @param scrollX hScrollBar horizontal offset
     * @param scrollY hScrollBar vertical offset
     * @param type
     */
    onScrollXY(scrollX, scrollY, type) {
        if (this.headerConfig.scrollX !== scrollX ||
            this.headerConfig.scrollY !== scrollY) {
            this.headerConfig.scrollX = scrollX;
            this.headerConfig.scrollY = scrollY;
            this.render(type);
        }
    }
    /**
     * Only call when hRowScrollBar scrolls
     * @param rowHeaderScrollX  hRowScrollbar horizontal offset
     * @param type
     */
    onRowScrollX(rowHeaderScrollX, type) {
        if (this.headerConfig.scrollX !== rowHeaderScrollX) {
            this.headerConfig.scrollX = rowHeaderScrollX;
            this.render(type);
        }
    }
    /**
     * 清空热区，为重绘做准备，防止热区重复渲染
     * @param type 当前重绘的header类型
     */
    clearResizeAreaGroup(type) {
        if (!type) {
            return;
        }
        const foregroundGroup = this.parentNode;
        const resizerGroup = foregroundGroup === null || foregroundGroup === void 0 ? void 0 : foregroundGroup.getElementById(type);
        resizerGroup === null || resizerGroup === void 0 ? void 0 : resizerGroup.destroyChildren();
    }
    clear() {
        var _a, _b, _c;
        (_a = this.scrollGroup) === null || _a === void 0 ? void 0 : _a.destroyChildren();
        (_b = this.frozenGroup) === null || _b === void 0 ? void 0 : _b.destroyChildren();
        (_c = this.frozenTrailingGroup) === null || _c === void 0 ? void 0 : _c.destroyChildren();
    }
    getNodes() {
        const { nodes } = this.getHeaderConfig();
        return nodes || [];
    }
    createOrUpdate(propertyPath, style) {
        createOrUpdateRect.call(this, propertyPath, style);
    }
}
//# sourceMappingURL=base.js.map