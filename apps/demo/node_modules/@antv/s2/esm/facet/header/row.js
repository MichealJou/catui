import { Group } from '@antv/g';
import { each } from 'lodash';
import { RowCell } from '../../cell';
import { RowCellPool } from '../../cell/pool';
import { FRONT_GROUND_GROUP_FROZEN_Z_INDEX, FRONT_GROUND_GROUP_SCROLL_Z_INDEX, FrozenGroupArea, KEY_GROUP_ROW_FROZEN, KEY_GROUP_ROW_FROZEN_TRAILING, KEY_GROUP_ROW_SCROLL, S2Event, } from '../../common';
import { translateGroup } from '../utils';
import { BaseHeader } from './base';
import { getExtraFrozenRowNodes, getFrozenTrailingRowOffset } from './util';
/**
 * Row Header for SpreadSheet
 */
export class RowHeader extends BaseHeader {
    constructor() {
        super(...arguments);
        this.rowCellPool = new RowCellPool();
    }
    initGroups() {
        this.scrollGroup = this.appendChild(new Group({
            name: KEY_GROUP_ROW_SCROLL,
            style: { zIndex: FRONT_GROUND_GROUP_SCROLL_Z_INDEX },
        }));
        this.frozenGroup = this.appendChild(new Group({
            name: KEY_GROUP_ROW_FROZEN,
            style: { zIndex: FRONT_GROUND_GROUP_FROZEN_Z_INDEX },
        }));
        this.frozenTrailingGroup = this.appendChild(new Group({
            name: KEY_GROUP_ROW_FROZEN_TRAILING,
            style: { zIndex: FRONT_GROUND_GROUP_FROZEN_Z_INDEX },
        }));
        const { spreadsheet } = this.getHeaderConfig();
        this.extraFrozenNodes = getExtraFrozenRowNodes(spreadsheet.facet);
    }
    getCellInstance(node) {
        var _a;
        if (this.rowCellPool.pool.length > 0 &&
            ((_a = this.headerConfig.spreadsheet.options.future) === null || _a === void 0 ? void 0 : _a.experimentalReuseCell)) {
            const rowCell = this.rowCellPool.acquire();
            rowCell.reInitCell(node, this.headerConfig);
            return rowCell;
        }
        const headerConfig = this.getHeaderConfig();
        const { spreadsheet } = headerConfig;
        const { rowCell } = spreadsheet.options;
        return ((rowCell === null || rowCell === void 0 ? void 0 : rowCell(node, spreadsheet, headerConfig)) ||
            new RowCell(node, spreadsheet, headerConfig));
    }
    // row'cell only show when visible
    isCellInRect(node) {
        const { width, viewportHeight, position, scrollY = 0, scrollX = 0, spreadsheet, } = this.getHeaderConfig();
        const frozenGroupAreas = spreadsheet.facet
            .frozenGroupAreas;
        return (
        // bottom
        viewportHeight +
            scrollY -
            frozenGroupAreas[FrozenGroupArea.TrailingRow].height >
            node.y &&
            // top
            scrollY + frozenGroupAreas[FrozenGroupArea.Row].height <
                node.y + node.height &&
            // left
            width + scrollX - position.x > node.x &&
            // right
            scrollX - position.x < node.x + node.width);
    }
    getCellGroup(item) {
        if (item.isFrozenHead) {
            return this.frozenGroup;
        }
        if (item.isFrozenTrailing) {
            return this.frozenTrailingGroup;
        }
        return this.scrollGroup;
    }
    layout() {
        const { nodes } = this.getHeaderConfig();
        const appendNode = (node) => {
            var _a;
            const group = this.getCellGroup(node);
            let cell;
            if (((_a = node.belongsCell) === null || _a === void 0 ? void 0 : _a.parentNode) === group &&
                node.belongsCell.getMeta() === node) {
                cell = node.belongsCell;
                cell.setHeaderConfig(this.headerConfig);
                cell.updateTextPosition();
            }
            else {
                cell = this.getCellInstance(node);
                node.belongsCell = cell;
                if (cell.parentElement !== group) {
                    group === null || group === void 0 ? void 0 : group.appendChild(cell);
                }
            }
            this.emitRenderEvent(cell);
        };
        // row'cell only show when visible
        each(nodes, (node) => {
            if (this.isCellInRect(node) && node.height !== 0) {
                appendNode(node);
            }
        });
        each(this.extraFrozenNodes, (node) => {
            if (node.height !== 0) {
                appendNode(node);
            }
        });
    }
    emitRenderEvent(cell) {
        const { spreadsheet } = this.getHeaderConfig();
        spreadsheet.emit(S2Event.ROW_CELL_RENDER, cell);
        spreadsheet.emit(S2Event.LAYOUT_CELL_RENDER, cell);
    }
    offset() {
        const { scrollX = 0, scrollY = 0, position, spreadsheet, viewportHeight, } = this.getHeaderConfig();
        const translateX = position.x - scrollX;
        const paginationScrollY = spreadsheet.facet.getPaginationScrollY();
        const facet = spreadsheet.facet;
        const trailingRowOffset = getFrozenTrailingRowOffset(facet, viewportHeight, paginationScrollY);
        translateGroup(this.scrollGroup, translateX, position.y - scrollY);
        translateGroup(this.frozenGroup, translateX, position.y - paginationScrollY);
        translateGroup(this.frozenTrailingGroup, translateX, position.y - trailingRowOffset);
    }
    clip() {
        const { width, viewportHeight, position, spreadsheet } = this.getHeaderConfig();
        const frozenGroupAreas = spreadsheet.facet
            .frozenGroupAreas;
        const frozenRowGroupHeight = frozenGroupAreas[FrozenGroupArea.Row].height;
        const frozenTrailingRowGroupHeight = frozenGroupAreas[FrozenGroupArea.TrailingRow].height;
        this.createOrUpdate('scrollGroup.style.clipPath', {
            x: spreadsheet.facet.cornerBBox.x,
            y: position.y + frozenRowGroupHeight,
            width,
            height: viewportHeight - frozenRowGroupHeight - frozenTrailingRowGroupHeight,
        });
        this.createOrUpdate('frozenGroup.style.clipPath', {
            x: spreadsheet.facet.cornerBBox.x,
            y: position.y,
            width,
            height: frozenRowGroupHeight,
        });
        this.createOrUpdate('frozenTrailingGroup.style.clipPath', {
            x: spreadsheet.facet.cornerBBox.x,
            y: position.y + viewportHeight - frozenTrailingRowGroupHeight,
            width,
            height: frozenTrailingRowGroupHeight,
        });
    }
    clear() {
        var _a;
        if ((_a = this.headerConfig.spreadsheet.options.future) === null || _a === void 0 ? void 0 : _a.experimentalReuseCell) {
            // @ts-ignore
            this.scrollGroup.childNodes.forEach((rowCell) => {
                if (!this.isCellInRect(rowCell.getMeta())) {
                    rowCell.getMeta().belongsCell = null;
                    this.rowCellPool.release(rowCell);
                }
            });
        }
        else {
            super.clear();
        }
    }
}
//# sourceMappingURL=row.js.map