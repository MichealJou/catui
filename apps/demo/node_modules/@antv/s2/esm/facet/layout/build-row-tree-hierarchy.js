import { isEmpty, isNumber } from 'lodash';
import { TOTAL_VALUE, i18n } from '../../common';
import { filterOutDetail } from '../../utils/data-set-operate';
import { generateId } from '../../utils/layout/generate-id';
import { layoutArrange, layoutHierarchy } from '../layout/layout-hooks';
import { Node } from '../layout/node';
import { TotalClass } from '../layout/total-class';
const addTotals = (spreadsheet, currentField, fieldValues) => {
    const totalsConfig = spreadsheet.getTotalsConfig(currentField);
    /**
     * tree mode only has grand totals, but if there are subTotals configs,
     * it will display in cross-area cell
     */
    if (totalsConfig === null || totalsConfig === void 0 ? void 0 : totalsConfig.showGrandTotals) {
        const func = totalsConfig.reverseGrandTotalsLayout ? 'unshift' : 'push';
        fieldValues[func](new TotalClass({
            label: totalsConfig.grandTotalsLabel,
            isGrandTotals: true,
            isSubTotals: false,
            isTotalRoot: false,
        }));
    }
};
/**
 * Only row header has tree hierarchy, in this scene:
 * 1、value in rows is not work => valueInCols is ineffective
 * 2、can't add extra sub total node in row
 * @param params
 */
export const buildRowTreeHierarchy = (params) => {
    var _a, _b, _c, _d, _e, _f, _g;
    const { spreadsheet, parentNode, currentField, level, hierarchy, pivotMeta } = params;
    const { query, id: parentId } = parentNode;
    const isDrillDownItem = ((_c = (_b = (_a = spreadsheet.dataCfg) === null || _a === void 0 ? void 0 : _a.fields) === null || _b === void 0 ? void 0 : _b.rows) === null || _c === void 0 ? void 0 : _c.length) <= level;
    const dimValues = filterOutDetail(Array.from(pivotMeta.keys()));
    let fieldValues = layoutArrange(spreadsheet, dimValues, parentNode, currentField);
    // limit displayed drill down data by drillItemsNum
    const drillItemsNum = spreadsheet.store.get('drillItemsNum');
    if (isDrillDownItem && drillItemsNum > 0) {
        fieldValues = fieldValues.slice(0, drillItemsNum);
    }
    if (level === 0) {
        addTotals(spreadsheet, currentField, fieldValues);
    }
    for (const fieldValue of fieldValues) {
        const isTotals = fieldValue instanceof TotalClass;
        const pivotMetaValue = isTotals
            ? null
            : pivotMeta.get(fieldValue);
        let value;
        let nodeQuery = query;
        let isGrandTotals = false;
        let isSubTotals = false;
        if (isTotals) {
            const totalClass = fieldValue;
            isGrandTotals = totalClass.isGrandTotals;
            isSubTotals = totalClass.isSubTotals;
            value = i18n(fieldValue.label);
            nodeQuery = query;
        }
        else {
            value = fieldValue;
            nodeQuery = Object.assign(Object.assign({}, query), { [currentField]: value });
        }
        const nodeId = generateId(parentId, value);
        const { collapseFields, collapseAll, expandDepth } = (_d = spreadsheet.options.style) === null || _d === void 0 ? void 0 : _d.rowCell;
        /**
         * 行头收起/展开配置优先级:collapseFields -> expandDepth -> collapseAll
         * 优先从读取 collapseFields 中的特定 node 的值
         * 如果没有特定配置，再查看是否配置了层级展开配置，
         * 最后再降级到 collapseAll 中
         */
        const isDefaultCollapsed = (_e = collapseFields === null || collapseFields === void 0 ? void 0 : collapseFields[nodeId]) !== null && _e !== void 0 ? _e : collapseFields === null || collapseFields === void 0 ? void 0 : collapseFields[currentField];
        // 如果 level 大于 rowExpandDepth 或者没有配置层级展开配置时，返回 null，保证能正确降级到 collapseAll
        const isLevelCollapsed = isNumber(expandDepth) ? level > expandDepth : null;
        const isCollapsed = (_f = isDefaultCollapsed !== null && isDefaultCollapsed !== void 0 ? isDefaultCollapsed : isLevelCollapsed) !== null && _f !== void 0 ? _f : collapseAll;
        const node = new Node({
            id: nodeId,
            value,
            level,
            parent: parentNode,
            field: currentField,
            isTotals,
            isGrandTotals,
            isSubTotals,
            isCollapsed,
            hierarchy,
            query: nodeQuery,
            spreadsheet,
        });
        if (level > hierarchy.maxLevel) {
            hierarchy.maxLevel = level;
        }
        /**
         * 除了虚拟行小计节点外, 如果为空, 说明当前分组只有一条数据, 应该标记为叶子节点.
         * https://github.com/antvis/S2/issues/2804
         */
        const children = [...(((_g = pivotMetaValue === null || pivotMetaValue === void 0 ? void 0 : pivotMetaValue.children) === null || _g === void 0 ? void 0 : _g.keys()) || [])].filter((child) => child !== TOTAL_VALUE);
        const isEmptyChildren = isEmpty(children);
        if (isEmptyChildren || isTotals) {
            node.isLeaf = true;
        }
        if (!isEmptyChildren) {
            node.isTotals = true;
        }
        const expandCurrentNode = layoutHierarchy(spreadsheet, parentNode, node, hierarchy);
        if (!isEmptyChildren && !isCollapsed && !isTotals && expandCurrentNode) {
            buildRowTreeHierarchy({
                level: level + 1,
                currentField: pivotMetaValue.childField,
                pivotMeta: pivotMetaValue.children,
                parentNode: node,
                hierarchy,
                spreadsheet,
            });
        }
    }
};
//# sourceMappingURL=build-row-tree-hierarchy.js.map