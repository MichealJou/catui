import { __rest } from "tslib";
import { isEmpty, isNumber } from 'lodash';
import { EXTRA_FIELD } from '../../common/constant';
import { generateId } from '../../utils/layout/generate-id';
import { Node } from '../layout/node';
import { layoutHierarchy } from './layout-hooks';
/**
 * è‡ªå®šä¹‰ðŸŒ²ç»“æž„è®¾è®¡åŽŸåˆ™ï¼š
 * 1ã€æ¸²æŸ“çš„èŠ‚ç‚¹ç”±ä¼ å…¥çš„æ•°æ®ç»“æž„å†³å®š, ä¸ç®¡æ˜¯å¹³é“º,è¿˜æ˜¯æ ‘çŠ¶, æœ¬è´¨ä¸Šéƒ½æ˜¯æ ‘çŠ¶ç»“æž„
 * 2ã€æ²¡æœ‰æ€»è®¡å°è®¡çš„æ¦‚å¿µ
 * 3ã€æ˜¯å¦å±•å¼€å’Œæ”¶èµ·å®Œå…¨ç”± customTreeNode.collapsed æ¥æŽ§åˆ¶ï¼ˆé»˜è®¤éƒ½å±•å¼€ï¼‰
 * 4ã€æ”¯æŒè¡Œå¤´/åˆ—å¤´è‡ªå®šä¹‰
 * 5ã€æ”¯æŒéšè—åˆ—å¤´
 * @param params
 */
export const buildCustomTreeHierarchy = (params) => {
    var _a;
    const { tree = [], level, parentNode, hierarchy, spreadsheet, isRowHeader, } = params;
    const { collapseFields, collapseAll, expandDepth } = (_a = spreadsheet.options.style) === null || _a === void 0 ? void 0 : _a.rowCell;
    const hiddenColumnsDetail = spreadsheet.store.get('hiddenColumnsDetail') || [];
    tree.forEach((treeNode) => {
        var _a, _b;
        const { field, title, collapsed, children } = treeNode, rest = __rest(treeNode, ["field", "title", "collapsed", "children"]);
        const isHiddenNode = hiddenColumnsDetail.some(({ hideColumnNodes }) => hideColumnNodes.find((hideNode) => hideNode.field === field));
        // query åªä¸Žå€¼æœ¬èº«æœ‰å…³ï¼Œä¸ä¼šæ¶‰åŠåˆ° parent èŠ‚ç‚¹
        const valueQuery = { [EXTRA_FIELD]: field };
        // ä½¿ç”¨ field ä½œä¸º id, ä¿è¯å…¶å”¯ä¸€æ€§, å¤åˆ¶æ—¶å†åšäºŒæ¬¡è½¬æ¢
        const nodeId = generateId(parentNode.id, field);
        const defaultCollapsed = collapsed !== null && collapsed !== void 0 ? collapsed : false;
        const isDefaultCollapsed = (_a = collapseFields === null || collapseFields === void 0 ? void 0 : collapseFields[nodeId]) !== null && _a !== void 0 ? _a : collapseFields === null || collapseFields === void 0 ? void 0 : collapseFields[field];
        // å¦‚æžœ level å¤§äºŽ rowExpandDepth æˆ–è€…æ²¡æœ‰é…ç½®å±‚çº§å±•å¼€é…ç½®æ—¶ï¼Œè¿”å›ž nullï¼Œä¿è¯èƒ½æ­£ç¡®é™çº§åˆ° collapseAll
        const isLevelCollapsed = isNumber(expandDepth) ? level > expandDepth : null;
        const isCollapsed = (_b = isDefaultCollapsed !== null && isDefaultCollapsed !== void 0 ? isDefaultCollapsed : isLevelCollapsed) !== null && _b !== void 0 ? _b : (collapseAll || defaultCollapsed);
        // TODO: å¹³é“ºæ¨¡å¼æ”¯æŒ æŠ˜å /å±•å¼€: https://github.com/antvis/S2/issues/2019
        const isCollapsedNode = spreadsheet.isHierarchyTreeType() && isRowHeader && isCollapsed;
        const isLeaf = isEmpty(children);
        const node = new Node({
            id: nodeId,
            field,
            value: title,
            level,
            parent: parentNode,
            // è‡ªå®šä¹‰è¡Œå¤´ä¸ä¼šå­˜åœ¨æ€»è®¡æ¦‚å¿µ
            isTotals: false,
            isCollapsed: isCollapsedNode,
            hierarchy,
            query: valueQuery,
            spreadsheet,
            isLeaf,
            extra: Object.assign(Object.assign({}, rest), { isCustomNode: true }),
        });
        if (isLeaf || isHiddenNode || isCollapsedNode) {
            hierarchy.pushIndexNode(node);
        }
        if (isHiddenNode) {
            return;
        }
        if (level > hierarchy.maxLevel && !node.isSeriesNumberNode()) {
            hierarchy.maxLevel = level;
            hierarchy.sampleNodesForAllLevels.push(node);
            hierarchy.sampleNodeForLastLevel = node;
            hierarchy.maxLevel = level;
        }
        const expandCurrentNode = layoutHierarchy(spreadsheet, parentNode, node, hierarchy);
        if (!isEmpty(children) && !isCollapsedNode && expandCurrentNode) {
            buildCustomTreeHierarchy({
                spreadsheet,
                parentNode: node,
                level: level + 1,
                hierarchy,
                tree: (children || []),
                isRowHeader,
            });
        }
    });
};
//# sourceMappingURL=build-row-custom-tree-hierarchy.js.map