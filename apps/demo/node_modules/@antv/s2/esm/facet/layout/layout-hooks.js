import { each, isBoolean, isEmpty } from 'lodash';
/**
 * re-arrange field values by custom arrange hooks
 */
export const layoutArrange = (spreadsheet, fieldValues, parent, field) => {
    if (spreadsheet.options.layoutArrange) {
        return spreadsheet.options.layoutArrange(spreadsheet, parent, field, fieldValues);
    }
    return fieldValues;
};
/**
 * Push node directly or custom push according to Hierarchy Hooks
 */
export const layoutHierarchy = (spreadsheet, parentNode, currentNode, hierarchy) => {
    var _a, _b, _c, _d;
    const hiddenColumnNode = (_a = spreadsheet === null || spreadsheet === void 0 ? void 0 : spreadsheet.facet) === null || _a === void 0 ? void 0 : _a.getHiddenColumnsInfo(currentNode);
    if (hiddenColumnNode &&
        (
        // fix: Only hiding the column headers is supported to prevent the row subtotals from being hidden when the IDs of the row totals and column totals are the same.
        (_d = (_c = (_b = spreadsheet === null || spreadsheet === void 0 ? void 0 : spreadsheet.dataSet) === null || _b === void 0 ? void 0 : _b.fields) === null || _c === void 0 ? void 0 : _c.columns) === null || _d === void 0 ? void 0 : _d.find((field) => field === (currentNode === null || currentNode === void 0 ? void 0 : currentNode.field)))) {
        return false;
    }
    let expandCurrentNode = true;
    const addNode = (node, insetIndex = -1, hierarchyIndex = -1) => {
        if (insetIndex === -1) {
            // add in parent
            parentNode.children.push(node);
            hierarchy.pushNode(node);
        }
        else {
            parentNode.children.splice(insetIndex, 0, node);
            hierarchy.pushNode(node, hierarchyIndex);
        }
    };
    if (spreadsheet.options.layoutHierarchy) {
        const facetLayoutHierarchy = spreadsheet.options.layoutHierarchy(spreadsheet, currentNode);
        if (facetLayoutHierarchy) {
            const deleteNode = !isBoolean(facetLayoutHierarchy === null || facetLayoutHierarchy === void 0 ? void 0 : facetLayoutHierarchy.delete)
                ? false
                : facetLayoutHierarchy === null || facetLayoutHierarchy === void 0 ? void 0 : facetLayoutHierarchy.delete;
            expandCurrentNode = !deleteNode;
            const { push: pushNodes, unshift: unshiftNodes } = facetLayoutHierarchy;
            let currentIndex = parentNode.children.length;
            let hierarchyIndex = hierarchy.getNodes().length;
            if (!isEmpty(unshiftNodes)) {
                each(unshiftNodes, (node) => {
                    addNode(node);
                });
                currentIndex = parentNode.children.length;
                hierarchyIndex = hierarchy.getNodes().length;
            }
            if (!isEmpty(pushNodes)) {
                each(pushNodes, (node) => {
                    addNode(node);
                });
            }
            if (!deleteNode) {
                addNode(currentNode, currentIndex, hierarchyIndex);
            }
        }
        else {
            addNode(currentNode);
        }
    }
    else {
        addNode(currentNode);
    }
    return expandCurrentNode;
};
/**
 * custom control every header node's coordinates
 */
export const layoutCoordinate = (spreadsheet, rowNode, colNode) => {
    var _a, _b;
    if ((_a = spreadsheet.options) === null || _a === void 0 ? void 0 : _a.layoutCoordinate) {
        // only leaf node's coordinates can be modified
        if ((rowNode === null || rowNode === void 0 ? void 0 : rowNode.isLeaf) || (colNode === null || colNode === void 0 ? void 0 : colNode.isLeaf)) {
            (_b = spreadsheet.options) === null || _b === void 0 ? void 0 : _b.layoutCoordinate(spreadsheet, rowNode, colNode);
        }
    }
};
//# sourceMappingURL=layout-hooks.js.map