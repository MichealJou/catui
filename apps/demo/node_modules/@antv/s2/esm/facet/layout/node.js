import { assign, head, isEmpty } from 'lodash';
import { SERIES_NUMBER_FIELD } from '../../common';
import { ROOT_NODE_ID } from '../../common/constant/node';
/**
 * Node for cornerHeader, colHeader, rowHeader
 */
export class Node {
    constructor(cfg) {
        // node top-left x-coordinate
        this.x = 0;
        // node top-left y-coordinate
        this.y = 0;
        // node width
        this.width = 0;
        // node height
        this.height = 0;
        // cell index in layout list
        this.colIndex = -1;
        // node's level in tree hierarchy
        this.level = 0;
        // check if node is leaf(the max level in tree)
        this.isLeaf = false;
        // node's children
        this.children = [];
        // node width adaptive mode need paddingLeft = paddingRight
        this.padding = 0;
        this.extra = {};
        assign(this, cfg);
    }
    /**
     * Get node's field path
     * eg: node.id = root[&]东北[&]黑龙江
     * => [area, province]
     * @param node
     */
    static getFieldPath(node, isDrillDown) {
        if ((node && !node.isTotals) || (node && isDrillDown)) {
            // total nodes don't need rows from node self except in drill down mode
            let parent = node.parent;
            const fieldPath = [node.field];
            while (parent && parent.id !== ROOT_NODE_ID) {
                fieldPath.push(parent.field);
                parent = parent.parent;
            }
            return fieldPath.reverse();
        }
        return [];
    }
    /**
     * Get all leaves in this node branch, eg:
     *        c1
     *    b1〈
     *        c2
     * a〈
     *        c3
     *    b2〈
     *        c4
     * get a branch's all leaves(c1~c4)
     * @param node
     */
    static getAllLeaveNodes(node) {
        const leaves = [];
        if (node.isLeaf) {
            return [node];
        }
        // current root node children
        const nodes = [...(node.children || [])];
        let current = nodes.shift();
        while (current) {
            if (current.isLeaf) {
                leaves.push(current);
            }
            else {
                nodes.unshift(...current.children);
            }
            current = nodes.shift();
        }
        return leaves;
    }
    /**
     * Get all children nodes in this node branch, eg:
     *        c1
     *    b1〈
     *        c2
     * a〈
     *        c3
     *    b2〈
     *        c4
     * get a branch's all nodes(c1~c4, b1, b2)
     * @param node
     */
    static getAllChildrenNodes(node, push = (node) => [node]) {
        const all = [];
        if (node.isLeaf) {
            all.push(...push(node));
            return all;
        }
        // current root node children
        const nodes = [...(node.children || [])];
        let current = nodes.shift();
        while (current) {
            all.push(...push(current));
            nodes.unshift(...current.children);
            current = nodes.shift();
        }
        return all;
    }
    /**
     *        c1
     *    b1〈
     *        c2
     * a〈
     *        c3
     *    b2〈
     *        c4
     * c1 => (a, b1, c1)
     * @param node
     */
    static getBranchNodes(node) {
        if (node && !node.isTotals) {
            let parent = node.parent;
            const pathNodes = [node];
            while (parent && parent.id !== ROOT_NODE_ID) {
                pathNodes.push(parent);
                parent = parent.parent;
            }
            return pathNodes.reverse();
        }
        return [];
    }
    static blankNode() {
        return new Node({
            id: '',
            field: '',
            value: '',
        });
    }
    static rootNode() {
        return new Node({
            id: ROOT_NODE_ID,
            field: '',
            value: '',
        });
    }
    getHeadLeafChild() {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let leafChild = this;
        while (!isEmpty(leafChild === null || leafChild === void 0 ? void 0 : leafChild.children)) {
            leafChild = head(leafChild === null || leafChild === void 0 ? void 0 : leafChild.children);
        }
        return leafChild;
    }
    /**
     * 获取树状模式下，当前节点以及其所有子节点的高度总和
     *
     */
    getTotalHeightForTreeHierarchy() {
        if (this.height === 0 || isEmpty(this.children)) {
            return this.height;
        }
        return this.children.reduce((sum, child) => sum + child.getTotalHeightForTreeHierarchy(), this.height);
    }
    isSeriesNumberNode() {
        return this.field === SERIES_NUMBER_FIELD;
    }
    clone() {
        return new Node(Object.assign({}, this));
    }
    get isFrozen() {
        return this.isFrozenHead || this.isFrozenTrailing;
    }
}
//# sourceMappingURL=node.js.map