import { each, filter, hasIn, isFunction, isObject, orderBy } from 'lodash';
import { getEmptyPlaceholder } from '../utils';
import { isAscSort, isDescSort } from '../utils/sort-action';
import { BaseDataSet } from './base-data-set';
export class TableDataSet extends BaseDataSet {
    constructor() {
        super(...arguments);
        this.handleDimensionValueFilter = () => {
            each(this.filterParams, ({ filterKey, filteredValues, customFilter }) => {
                const filteredValuesSet = new Set(filteredValues);
                const defaultFilterFunc = (row) => !filteredValuesSet.has(row[filterKey]);
                const filteredData = filter(this.displayData, (row) => {
                    if (customFilter) {
                        return customFilter(row) && defaultFilterFunc(row);
                    }
                    return defaultFilterFunc(row);
                });
                this.displayData = this.getDisplayData(filteredData);
            });
        };
        //  sortFunc > sortBy > sortFieldId
        this.handleDimensionValuesSort = () => {
            each(this.sortParams, (item) => {
                var _a;
                const { sortFieldId, sortBy, sortFunc, sortMethod, query } = item;
                // 排序的前提
                if (!sortFieldId) {
                    return;
                }
                let data = this.displayData;
                const restData = [];
                if (query) {
                    const scopedData = [];
                    data.forEach((record) => {
                        const keys = Object.keys(query);
                        let inScope = true;
                        for (let index = 0; index < keys.length; index++) {
                            const k = keys[index];
                            if (record[k] !== query[k]) {
                                inScope = false;
                                restData.push(record);
                                break;
                            }
                        }
                        if (inScope) {
                            scopedData.push(record);
                        }
                    });
                    data = scopedData;
                }
                let sortedData = data;
                if (sortFunc) {
                    sortedData = sortFunc(Object.assign(Object.assign({}, item), { data }));
                }
                else if (sortBy && !isFunction(sortBy)) {
                    const reversedSortBy = [...sortBy].reverse();
                    sortedData = data.sort((a, b) => {
                        const idxA = reversedSortBy.indexOf(a[sortFieldId]);
                        const idxB = reversedSortBy.indexOf(b[sortFieldId]);
                        return idxB - idxA;
                    });
                }
                else if (isAscSort(sortMethod) || isDescSort(sortMethod)) {
                    const placeholder = getEmptyPlaceholder(this.spreadsheet, (_a = this.spreadsheet.options) === null || _a === void 0 ? void 0 : _a.placeholder);
                    const customSortBy = isFunction(sortBy) ? sortBy : null;
                    const customSort = (record) => {
                        // 空值占位符按最小值处理 https://github.com/antvis/S2/issues/2707
                        if (record[sortFieldId] === placeholder) {
                            return Number.MIN_VALUE;
                        }
                        return record[sortFieldId];
                    };
                    sortedData = orderBy(data, [customSortBy || customSort], [sortMethod === null || sortMethod === void 0 ? void 0 : sortMethod.toLocaleLowerCase()]);
                }
                if (restData.length) {
                    sortedData = [...sortedData, ...restData];
                }
                // For frozen options
                this.displayData = this.getDisplayData(sortedData);
            });
        };
    }
    processDataCfg(dataCfg) {
        return dataCfg;
    }
    setDataCfg(dataCfg) {
        super.setDataCfg(dataCfg);
        this.handleDimensionValueFilter();
        this.handleDimensionValuesSort();
    }
    /**
     * 返回顶部冻结行
     * @returns
     */
    getStartFrozenRows(displayData) {
        const { rowCount } = this.spreadsheet.options.frozen || {};
        if (!rowCount) {
            return [];
        }
        return displayData.slice(0, rowCount);
    }
    /**
     * 返回底部冻结行
     * @returns
     */
    getEndFrozenRows(displayData) {
        const { trailingRowCount } = this.spreadsheet.options.frozen || {};
        // 没有冻结行时返回空数组
        if (!trailingRowCount) {
            return [];
        }
        return displayData.slice(-trailingRowCount);
    }
    getDisplayData(displayData) {
        const startFrozenRows = this.getStartFrozenRows(displayData);
        const endFrozenRows = this.getEndFrozenRows(displayData);
        const data = displayData.slice(startFrozenRows.length || 0, -endFrozenRows.length || undefined);
        return [...startFrozenRows, ...data, ...endFrozenRows];
    }
    getDimensionValues() {
        return [];
    }
    getCellData({ query = {} } = {}) {
        if (this.displayData.length === 0 && query['rowIndex'] === 0) {
            return undefined;
        }
        const rowData = this.displayData[query['rowIndex']];
        if (!hasIn(query, 'field') || !isObject(rowData)) {
            return rowData;
        }
        return rowData[query['field']];
    }
    getCellMultiData({ query = {} } = {}) {
        if (!query) {
            return this.displayData;
        }
        const rowData = this.displayData[query['rowIndex']]
            ? [this.displayData[query['rowIndex']]]
            : this.displayData;
        if (!hasIn(query, 'field')) {
            return rowData;
        }
        return rowData.map((item) => item[query['field']]);
    }
    getRowData(cell) {
        return this.getCellData({
            query: {
                rowIndex: cell.rowIndex,
            },
        });
    }
}
//# sourceMappingURL=table-data-set.js.map