import { isEmpty } from 'lodash';
import { CellType } from '../common/constant';
import { CellBorderPosition } from '../common/interface';
import { getBorderPositionAndStyle } from '../utils/cell/cell';
import { getPolygonPoints, getRightAndBottomCells, } from '../utils/cell/merged-cell';
import { renderLine, renderPolygon } from '../utils/g-renders';
import { drawCustomContent } from '../utils/text';
import { DataCell } from './data-cell';
/**
 * Cell for panelGroup area
 */
export class MergedCell extends DataCell {
    get cellType() {
        return CellType.MERGED_CELL;
    }
    constructor(spreadsheet, cells, meta) {
        super(meta, spreadsheet, cells);
    }
    handleRestOptions(...[cells]) {
        this.cells = cells;
    }
    update() { }
    initCell() {
        this.resetTextAndConditionIconShapes();
        // TODO：1、交互态扩展； 2、合并后的单元格文字布局及文字内容（目前参考Excel合并后只保留第一个单元格子的数据）
        this.drawBackgroundShape();
        this.drawTextOrCustomRenderer();
    }
    afterDrawText() {
        this.drawBorders();
    }
    /**
     * Draw merged cells background
     */
    drawBackgroundShape() {
        const allPoints = getPolygonPoints(this.cells);
        const cellTheme = this.theme.dataCell.cell;
        this.backgroundShape = renderPolygon(this, {
            points: allPoints,
            fill: cellTheme.backgroundColor,
        });
    }
    drawTextShape() {
        if (isEmpty(this.meta)) {
            return;
        }
        if (this.isMultiData()) {
            return drawCustomContent(this);
        }
        super.drawTextShape();
    }
    drawBorders() {
        const { right, bottom, bottomRightCornerCell } = getRightAndBottomCells(this.cells);
        right.forEach((cell) => {
            var _a;
            const { position, style } = getBorderPositionAndStyle(CellBorderPosition.RIGHT, cell.getBBoxByType(), (_a = cell.getStyle()) === null || _a === void 0 ? void 0 : _a.cell);
            renderLine(this, Object.assign(Object.assign({}, position), style));
        });
        bottom.forEach((cell) => {
            var _a;
            const { position, style } = getBorderPositionAndStyle(CellBorderPosition.BOTTOM, cell.getBBoxByType(), (_a = cell.getStyle()) === null || _a === void 0 ? void 0 : _a.cell);
            renderLine(this, Object.assign(Object.assign({}, position), style));
        });
        bottomRightCornerCell.forEach((cell) => {
            var _a;
            const { x, y, width, height } = cell.getBBoxByType();
            const { horizontalBorderWidth = 0, verticalBorderWidth = 0, verticalBorderColor, } = (_a = cell.getStyle()) === null || _a === void 0 ? void 0 : _a.cell;
            const x1 = x + width - verticalBorderWidth / 2;
            const x2 = x1;
            const y1 = y + height - horizontalBorderWidth;
            const y2 = y + height;
            renderLine(this, {
                x1,
                x2,
                y1,
                y2,
                lineWidth: verticalBorderWidth,
                stroke: verticalBorderColor,
                strokeOpacity: verticalBorderWidth,
            });
        });
    }
}
//# sourceMappingURL=merged-cell.js.map