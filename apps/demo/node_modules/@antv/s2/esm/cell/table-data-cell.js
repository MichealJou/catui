import { DataCell } from '../cell/data-cell';
import { CellType, FrozenGroupArea, KEY_GROUP_ROW_RESIZE_AREA, ResizeAreaEffect, ResizeDirectionType, SERIES_NUMBER_FIELD, } from '../common/constant';
import { CustomRect } from '../engine';
import { isFrozenRow, isFrozenTrailingRow } from '../facet/utils';
import { getOrCreateResizeAreaGroupById, getResizeAreaAttrs, shouldAddResizeArea, } from '../utils/interaction/resize';
export class TableDataCell extends DataCell {
    getLinkFieldStyle() {
        return this.theme.rowCell.text.linkTextFill;
    }
    getTextStyle() {
        // 此逻辑不能放到seriesNumberCell中，否则在单元格复用场景下会导致文本样式错误
        if (this.meta.valueField === SERIES_NUMBER_FIELD) {
            const textOverflowStyle = this.getCellTextWordWrapStyle(CellType.SERIES_NUMBER_CELL);
            const style = this.theme.rowCell.seriesText;
            return Object.assign(Object.assign({}, textOverflowStyle), style);
        }
        return super.getTextStyle();
    }
    shouldDrawResizeArea() {
        // 每一行直绘制一条贯穿式 resize 热区
        const id = `${this.meta.rowIndex}`;
        const resizeArea = getOrCreateResizeAreaGroupById(this.spreadsheet, KEY_GROUP_ROW_RESIZE_AREA);
        return !(resizeArea === null || resizeArea === void 0 ? void 0 : resizeArea.getElementById(id));
    }
    drawResizeArea() {
        if (!this.shouldDrawResizeArea()) {
            return;
        }
        const resizeArea = getOrCreateResizeAreaGroupById(this.spreadsheet, KEY_GROUP_ROW_RESIZE_AREA);
        if (!resizeArea) {
            return;
        }
        const { rowIndex } = this.getMeta();
        const cellRange = this.spreadsheet.facet.getCellRange();
        const { rowCount, trailingRowCount } = this.spreadsheet.facet.getFrozenOptions();
        const isFrozenHead = isFrozenRow(rowIndex, cellRange.start, rowCount);
        const isFrozenTrailing = isFrozenTrailingRow(rowIndex, cellRange.end, trailingRowCount);
        const isFrozen = isFrozenHead || isFrozenTrailing;
        const { y, height } = this.getBBoxByType();
        const { x: panelBBoxX, y: panelBBoxY, viewportWidth, viewportHeight, } = this.spreadsheet.facet.panelBBox;
        const { scrollY } = this.spreadsheet.facet.getScrollOffset();
        const paginationSy = this.spreadsheet.facet.getPaginationScrollY();
        const frozenGroupAreas = this.spreadsheet.facet
            .frozenGroupAreas;
        const frozenRowGroup = frozenGroupAreas[FrozenGroupArea.Row];
        const frozenTrailingRowGroup = frozenGroupAreas[FrozenGroupArea.TrailingRow];
        const resizeStyle = this.getResizeAreaStyle();
        const width = panelBBoxX + viewportWidth;
        const resizeClipAreaBBox = {
            x: 0,
            y: isFrozen ? 0 : frozenRowGroup.height,
            width,
            height: isFrozen
                ? Number.POSITIVE_INFINITY
                : viewportHeight -
                    frozenRowGroup.height -
                    frozenTrailingRowGroup.height,
        };
        const resizeAreaBBox = {
            x: 0,
            y: y + height - resizeStyle.size,
            width,
            height: resizeStyle.size,
        };
        if (!shouldAddResizeArea(resizeAreaBBox, resizeClipAreaBBox, {
            scrollX: 0,
            scrollY: isFrozen ? 0 : paginationSy + scrollY,
        })) {
            return;
        }
        let offsetY = panelBBoxY;
        if (isFrozenHead) {
            offsetY += y - frozenRowGroup.y;
        }
        else if (isFrozenTrailing) {
            offsetY +=
                viewportHeight -
                    frozenTrailingRowGroup.height +
                    y -
                    frozenTrailingRowGroup.y;
        }
        else {
            offsetY += y - paginationSy - scrollY;
        }
        const attrs = getResizeAreaAttrs({
            theme: resizeStyle,
            type: ResizeDirectionType.Vertical,
            effect: ResizeAreaEffect.Cell,
            offsetX: 0,
            offsetY,
            width,
            height,
            meta: this.meta,
            cell: this,
        });
        resizeArea.appendChild(new CustomRect({
            style: Object.assign(Object.assign({}, attrs.style), { x: 0, y: offsetY + height - resizeStyle.size, width }),
        }, attrs.appendInfo));
    }
    isDisableHover(cellMeta) {
        return (cellMeta === null || cellMeta === void 0 ? void 0 : cellMeta.type) === CellType.COL_CELL;
    }
    getResizedTextMaxLines() {
        var _a, _b, _c, _d, _e;
        const { facet, options } = this.spreadsheet;
        const { rowCell } = options.style;
        const { id, rowId, rowIndex } = this.meta;
        return ((_d = (_b = (_a = rowCell === null || rowCell === void 0 ? void 0 : rowCell.maxLinesByField) === null || _a === void 0 ? void 0 : _a[id]) !== null && _b !== void 0 ? _b : (_c = rowCell === null || rowCell === void 0 ? void 0 : rowCell.maxLinesByField) === null || _c === void 0 ? void 0 : _c[rowId]) !== null && _d !== void 0 ? _d : this.getMaxLinesByCustomHeight({
            isCustomHeight: (_e = facet === null || facet === void 0 ? void 0 : facet.customRowHeightStatusMap) === null || _e === void 0 ? void 0 : _e[rowIndex],
        }));
    }
}
//# sourceMappingURL=table-data-cell.js.map