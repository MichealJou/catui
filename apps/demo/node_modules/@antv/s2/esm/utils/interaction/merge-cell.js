import { differenceWith, filter, find, forEach, isEmpty, isEqual, map, } from 'lodash';
import { MergedCell } from '../../cell/merged-cell';
import { CellType } from '../../common/constant';
/**
 * get cells on the outside of visible area through mergeCellInfo
 * @param invisibleCellInfo
 * @param sheet
 */
export const getInvisibleInfo = (invisibleCellInfo, sheet) => {
    const cells = [];
    let viewMeta;
    forEach(invisibleCellInfo, (cellInfo) => {
        var _a, _b;
        const meta = (_a = sheet === null || sheet === void 0 ? void 0 : sheet.facet) === null || _a === void 0 ? void 0 : _a.getCellMeta(cellInfo.rowIndex, cellInfo.colIndex);
        const cell = (_b = sheet === null || sheet === void 0 ? void 0 : sheet.facet) === null || _b === void 0 ? void 0 : _b.createDataCell(meta);
        if (cell) {
            cells.push(cell);
            viewMeta = (cellInfo === null || cellInfo === void 0 ? void 0 : cellInfo.showText) ? meta : viewMeta;
        }
    });
    return { cells, cellsMeta: viewMeta };
};
/**
 * get { cells, invisibleCellInfo, cellsMeta } in the inside of visible area through mergeCellInfo
 * @param cellsInfos
 * @param allVisibleCells
 * @returns { cells, invisibleCellInfo, cellsMeta }
 */
export const getVisibleInfo = (cellsInfos, allVisibleCells) => {
    const cells = [];
    const invisibleCellInfo = [];
    let cellsMeta;
    forEach(cellsInfos, (cellInfo) => {
        const findCell = find(allVisibleCells, (cell) => {
            var _a;
            const meta = (_a = cell === null || cell === void 0 ? void 0 : cell.getMeta) === null || _a === void 0 ? void 0 : _a.call(cell);
            if ((meta === null || meta === void 0 ? void 0 : meta.colIndex) === (cellInfo === null || cellInfo === void 0 ? void 0 : cellInfo.colIndex) &&
                (meta === null || meta === void 0 ? void 0 : meta.rowIndex) === (cellInfo === null || cellInfo === void 0 ? void 0 : cellInfo.rowIndex)) {
                return cell;
            }
        });
        if (findCell) {
            cells.push(findCell);
            cellsMeta = (cellInfo === null || cellInfo === void 0 ? void 0 : cellInfo.showText)
                ? findCell === null || findCell === void 0 ? void 0 : findCell.getMeta()
                : cellsMeta;
        }
        else {
            invisibleCellInfo.push(cellInfo);
        }
    });
    return { cells, invisibleCellInfo, cellsMeta };
};
/**
 * get the data cell and meta that make up the mergedCell
 * @param cellsInfos
 * @param allVisibleCells
 * @param sheet
 */
export const getTempMergedCell = (allVisibleCells, sheet, cellsInfos = []) => {
    var _a;
    const { cellsMeta, cells, invisibleCellInfo } = getVisibleInfo(cellsInfos, allVisibleCells);
    let viewMeta = cellsMeta;
    let mergedAllCells = cells;
    // some cells are invisible and some cells are visible
    const isPartiallyVisible = (invisibleCellInfo === null || invisibleCellInfo === void 0 ? void 0 : invisibleCellInfo.length) > 0 &&
        invisibleCellInfo.length < cellsInfos.length;
    // 当 MergedCell 只有部分在可视区域时，在此获取 MergedCell 不在可视区域内的 cells
    if (isPartiallyVisible) {
        const { cells: invisibleCells, cellsMeta: invisibleMeta } = getInvisibleInfo(invisibleCellInfo, sheet);
        viewMeta = viewMeta || invisibleMeta;
        mergedAllCells = cells.concat(invisibleCells);
    }
    if (!isEmpty(cells) && !viewMeta) {
        // 如果没有指定合并后的文本绘制的位置，默认画在选择的第一个单元格内
        viewMeta = (_a = mergedAllCells[0]) === null || _a === void 0 ? void 0 : _a.getMeta();
    }
    return {
        cells: mergedAllCells,
        viewMeta: viewMeta,
    };
};
/**
 * get the active cells' info as the default info of merged cells
 * @param sheet
 */
export const getActiveCellsInfo = (sheet) => {
    const { interaction } = sheet;
    const cells = interaction.getActiveCells();
    const mergedCellsInfo = [];
    forEach(cells, (cell, index) => {
        const meta = cell.getMeta();
        // 在合并单元格中，第一个单元格被标标记为展示数据。
        const showText = index === 0 ? { showText: true } : {};
        mergedCellsInfo.push(Object.assign(Object.assign({}, showText), { colIndex: meta === null || meta === void 0 ? void 0 : meta.colIndex, rowIndex: meta === null || meta === void 0 ? void 0 : meta.rowIndex }));
    });
    return mergedCellsInfo;
};
/**
 * 创建 merged cell 实例
 * @param spreadsheet 表格实例
 * @param cells 待合并的单元格
 * @param meta 元信息
 * @returns
 */
export const getMergedCellInstance = (spreadsheet, cells, meta) => {
    var _a;
    if ((_a = spreadsheet.options) === null || _a === void 0 ? void 0 : _a.mergedCell) {
        return spreadsheet.options.mergedCell(spreadsheet, cells, meta);
    }
    return new MergedCell(spreadsheet, cells, meta);
};
/**
 * draw the background of the merged cell
 * @param sheet the base sheet instance
 * @param cellsInfo
 * @param hideData
 */
export const mergeCell = (sheet, cellsInfo, hideData) => {
    var _a;
    const mergeCellInfo = cellsInfo || getActiveCellsInfo(sheet);
    if ((mergeCellInfo === null || mergeCellInfo === void 0 ? void 0 : mergeCellInfo.length) <= 1) {
        // eslint-disable-next-line no-console
        console.error('[mergeCell]: The merged cells must be more than one!');
        return;
    }
    const allVisibleCells = sheet.facet.getDataCells();
    const { cells, viewMeta } = getTempMergedCell(allVisibleCells, sheet, mergeCellInfo);
    if (!isEmpty(cells)) {
        const mergedCellInfoList = ((_a = sheet.options) === null || _a === void 0 ? void 0 : _a.mergedCellsInfo) || [];
        mergedCellInfoList.push(mergeCellInfo);
        sheet.setOptions({
            mergedCellsInfo: mergedCellInfoList,
        });
        const meta = hideData ? undefined : viewMeta;
        sheet.facet.panelScrollGroup.addMergeCell(getMergedCellInstance(sheet, cells, meta));
    }
};
/**
 * remove unmergedCells Info, return new mergedCell info
 * @param removeMergedCell
 * @param mergedCellsInfo
 */
export const removeUnmergedCellsInfo = (removeMergedCell, mergedCellsInfo) => {
    const removeCellInfo = map(removeMergedCell.cells, (cell) => {
        return {
            colIndex: cell.getMeta().colIndex,
            rowIndex: cell.getMeta().rowIndex,
        };
    });
    return filter(mergedCellsInfo, (mergedCellInfo) => {
        const newMergedCellInfo = mergedCellInfo.map((info) => {
            if (info.showText) {
                return {
                    colIndex: info.colIndex,
                    rowIndex: info.rowIndex,
                };
            }
            return info;
        });
        return !isEqual(newMergedCellInfo, removeCellInfo);
    });
};
/**
 * unmerge MergedCell
 * @param removedCell
 * @param sheet
 */
export const unmergeCell = (sheet, removedCell) => {
    var _a, _b, _c;
    if (!removedCell || removedCell.cellType !== CellType.MERGED_CELL) {
        // eslint-disable-next-line no-console
        console.error(`[unmergeCell]: The ${removedCell} is not a MergedCell`);
        return;
    }
    const newMergedCellsInfo = removeUnmergedCellsInfo(removedCell, ((_a = sheet.options) === null || _a === void 0 ? void 0 : _a.mergedCellsInfo) || []);
    if ((newMergedCellsInfo === null || newMergedCellsInfo === void 0 ? void 0 : newMergedCellsInfo.length) !== ((_c = (_b = sheet.options) === null || _b === void 0 ? void 0 : _b.mergedCellsInfo) === null || _c === void 0 ? void 0 : _c.length)) {
        sheet.setOptions({
            mergedCellsInfo: newMergedCellsInfo,
        });
        removedCell.remove();
    }
};
/**
 * 合并 TempMergedCell, 通过 cell.viewMeta.id 判断 TempMergedCell 是否是同一个。
 * @param TempMergedCells
 * @param otherTempMergedCells
 */
export const mergeTempMergedCell = (TempMergedCells, otherTempMergedCells) => {
    const mergedTempMergedCells = {};
    [...TempMergedCells, ...otherTempMergedCells].forEach((cell) => {
        mergedTempMergedCells[cell.viewMeta.id] = cell;
    });
    return Object.values(mergedTempMergedCells);
};
/**
 * 将 MergedCell 转换成 TempMergedCell
 * @param oldMergedCells
 * @constructor
 */
export const mergedCellConvertTempMergedCells = (oldMergedCells) => map(oldMergedCells, (mergedCell) => {
    return {
        cells: mergedCell.cells,
        viewMeta: mergedCell.getMeta(),
    };
});
/**
 * 对比两个TempMergedCell，返回 mainTempMergedCells 中存在的，但是 otherTempMergedCells 中不存在的的 TempMergedCell
 * @param mainTempMergedCells
 * @param compareTempMergedCells
 */
export const differenceTempMergedCells = (mainTempMergedCells, compareTempMergedCells) => differenceWith(mainTempMergedCells, compareTempMergedCells, (main, compare) => isEqual(main.viewMeta.id, compare.viewMeta.id));
/**
 * update the mergedCell
 * @param sheet the base sheet instance
 */
export const updateMergedCells = (sheet, mergedCellsGroup) => {
    var _a;
    const mergedCellsInfo = (_a = sheet.options) === null || _a === void 0 ? void 0 : _a.mergedCellsInfo;
    if (isEmpty(mergedCellsInfo)) {
        return;
    }
    // 可见区域的所有cells
    const allCells = sheet.facet.getDataCells();
    if (isEmpty(allCells)) {
        return;
    }
    // allVisibleTempMergedCells 所有可视区域的 mergedCell
    const allVisibleTempMergedCells = [];
    mergedCellsInfo.forEach((cellsInfo) => {
        const tempMergedCell = getTempMergedCell(allCells, sheet, cellsInfo);
        if (tempMergedCell.cells.length > 0) {
            allVisibleTempMergedCells.push(tempMergedCell);
        }
    });
    // 获取 oldTempMergedCells 便用后续进行 diff 操作
    const oldMergedCells = mergedCellsGroup.children;
    const oldTempMergedCells = mergedCellConvertTempMergedCells(oldMergedCells);
    // compare oldTempMergedCells and allTempMergedCells, find remove MergedCells and add MergedCells
    const removeTempMergedCells = differenceTempMergedCells(oldTempMergedCells, allVisibleTempMergedCells);
    const addTempMergedCells = differenceTempMergedCells(allVisibleTempMergedCells, oldTempMergedCells);
    // remove old MergedCells
    forEach(removeTempMergedCells, (tempMergedCell) => {
        const oldMergedCell = find(oldMergedCells, (mergedCell) => isEqual(mergedCell.getMeta().id, tempMergedCell.viewMeta.id));
        oldMergedCell === null || oldMergedCell === void 0 ? void 0 : oldMergedCell.remove();
    });
    // add new MergedCells
    forEach(addTempMergedCells, ({ cells, viewMeta }) => {
        mergedCellsGroup.appendChild(getMergedCellInstance(sheet, cells, viewMeta));
    });
};
//# sourceMappingURL=merge-cell.js.map