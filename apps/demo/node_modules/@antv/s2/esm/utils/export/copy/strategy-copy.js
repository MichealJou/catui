import { flatten, forEach, get, isArray, isNil, isObject, map } from 'lodash';
import { safeJsonParse } from '../../common';
import { getEmptyPlaceholder } from '../../text';
import { getHeaderList } from '../method';
import { assembleMatrix, getNodeFormatData } from './common';
import { PivotDataCellCopy } from './pivot-data-cell-copy';
/**
 * Process the multi-measure with single-lines
 */
const processObjectValueInRow = (data, isFormat = false) => {
    var _a;
    if (!isFormat) {
        return (_a = get(data, ['originalValues', 0])) !== null && _a !== void 0 ? _a : get(data, ['values', 0]);
    }
    return get(data, ['values', 0]);
};
const getHeaderLabel = (val) => {
    const label = safeJsonParse(val);
    if (isArray(label)) {
        return label;
    }
    return val;
};
class StrategyCopyData extends PivotDataCellCopy {
    constructor(props) {
        super(props);
        this.getPlaceholder = (viewMeta, leafNode) => {
            const label = getHeaderLabel(leafNode.value);
            const labelLength = isArray(label) ? label.length : 1;
            const { placeholder } = this.spreadsheet.options;
            const placeholderStr = getEmptyPlaceholder(viewMeta, placeholder);
            return Array(labelLength).fill(placeholderStr);
        };
        /* Process the data when the value position is on the rows. */
        this.processValueInRow = (viewMeta, placeholder) => {
            var _a, _b;
            let tempCellValues = [];
            const defaultResult = placeholder !== null && placeholder !== void 0 ? placeholder : [''];
            if (!viewMeta) {
                return defaultResult;
            }
            const { fieldValue, valueField, data } = viewMeta;
            if (isObject(fieldValue)) {
                tempCellValues = processObjectValueInRow(fieldValue, this.config.formatHeader);
                return tempCellValues !== null && tempCellValues !== void 0 ? tempCellValues : placeholder;
            }
            // 如果本身格子的数据是 null， 但是一个格子又需要绘制多个指标时，需要使用placeholder填充
            if (isNil(fieldValue) && placeholder.length > 1) {
                return defaultResult;
            }
            // The main measure.
            if (!this.config.formatHeader) {
                tempCellValues.push((_a = fieldValue) !== null && _a !== void 0 ? _a : '');
            }
            else {
                const mainFormatter = this.spreadsheet.dataSet.getFieldFormatter(valueField);
                const tempCellValue = (_b = mainFormatter(fieldValue, data)) !== null && _b !== void 0 ? _b : '';
                tempCellValues.push(tempCellValue);
            }
            return tempCellValues !== null && tempCellValues !== void 0 ? tempCellValues : placeholder;
        };
        this.getCornerMatrix = (rowMatrix) => {
            return this.getCustomRowCornerMatrix(rowMatrix);
        };
        this.getDataMatrixByHeaderNode = () => {
            return map(this.leafRowNodes, (rowNode) => {
                // 获取每行的数据，如果无法获取到数据则使用 placeholder 填充
                const rowVal = this.leafColNodes.map((colNode) => {
                    var _a, _b;
                    const viewMeta = (_b = (_a = this.spreadsheet.facet).getCellMeta) === null || _b === void 0 ? void 0 : _b.call(_a, rowNode.rowIndex, colNode.colIndex);
                    const placeholder = this.getPlaceholder(viewMeta, colNode);
                    return this.processValueInRow(viewMeta, placeholder);
                });
                // 因为每个格子可能有多个指标时，则以数组展示。对于行头来说，需要将每个格子的展示拍平
                return flatten(rowVal);
            });
        };
        this.getPivotAllCopyData = () => {
            const rowMatrix = this.getRowMatrix();
            const colMatrix = this.getColMatrix();
            const cornerMatrix = this.getCornerMatrix(rowMatrix);
            const dataMatrix = this.getDataMatrixByHeaderNode();
            return this.matrixTransformer(assembleMatrix({
                colMatrix,
                dataMatrix,
                rowMatrix,
                cornerMatrix,
            }), 
            // https://github.com/antvis/S2/issues/2701
            this.config.separator);
        };
    }
    // 趋势表都需要列头为"字符串数组类型"的 value, e.g.: "["数值","环比","同比"]"
    getColMatrix() {
        const result = [];
        forEach(this.leafColNodes, (node) => {
            const colList = this.config.formatHeader
                ? getNodeFormatData(node)
                : getHeaderList(node.id);
            // 倒着循环 colList
            let maxLen = 0;
            for (let i = colList.length - 1; i >= 0; i--) {
                const item = colList[i];
                let temp = [];
                // 如果是最后一个元素，且是 "["数值","环比","同比"]"，则需要转换
                if (item.startsWith('[') && item.endsWith(']')) {
                    temp = JSON.parse(item);
                    // 如果是 "["数值","环比","同比"]"，则转换为 "数值","环比","同比"
                    maxLen = temp.length > maxLen ? temp.length : maxLen;
                }
                else {
                    // 需要补全 "" 在后面，e.g.: "2022-09" => ["2022-09", "", ""]
                    temp = maxLen > 0 ? new Array(maxLen).fill('') : [];
                    temp[0] = item;
                }
                result[i] = result[i] ? result[i].concat(temp) : temp;
            }
        });
        return result;
    }
}
export const strategyCopy = (params) => {
    const { sheetInstance, split, formatOptions } = params;
    const strategyCopyData = new StrategyCopyData({
        spreadsheet: sheetInstance,
        isExport: true,
        config: {
            separator: split,
            formatOptions,
        },
    });
    return strategyCopyData.getPivotAllCopyData()[0].content;
};
//# sourceMappingURL=strategy-copy.js.map