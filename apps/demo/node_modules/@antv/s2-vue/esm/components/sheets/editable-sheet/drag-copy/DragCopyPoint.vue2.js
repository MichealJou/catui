var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import { S2Event, S2_PREFIX_CLS, FrozenGroupArea } from "@antv/s2";
import { pick, isEqual } from "lodash";
import { defineComponent, ref, watch, onUnmounted, computed } from "vue";
import { useSpreadSheetInstance } from "../../../../context/SpreadSheetContext.js";
import DragCopyMask from "./DragCopyMask.vue2.js";
/* empty css                     */
const _sfc_main = defineComponent({
  name: "DragCopyPoint",
  components: { DragCopyMask },
  setup() {
    const s2Ref = useSpreadSheetInstance();
    const scroll = ref({
      scrollX: -999,
      scrollY: -999,
      width: 8,
      overflow: true
    });
    const position = ref({ left: -999, top: -999 });
    const cell = ref();
    const handleScroll = () => {
      var _a;
      const spreadsheet = s2Ref.value;
      if (!spreadsheet) {
        return;
      }
      const newScroll = spreadsheet.facet.getScrollOffset();
      const frozenGroupAreas = spreadsheet.facet.frozenGroupAreas;
      const rect = spreadsheet.getCanvasElement().getBoundingClientRect();
      const cellMeta = (_a = cell.value) == null ? void 0 : _a.getMeta();
      if (!isEqual(newScroll, scroll.value)) {
        if (cellMeta) {
          const {
            verticalBorderWidth: vWidth = 0,
            horizontalBorderWidth: hWidth = 0
          } = cell.value.getStyle().cell;
          const pointX = cellMeta.width + cellMeta.x;
          const pointY = cellMeta.height + cellMeta.y;
          const pointWidth = pointX - newScroll.scrollX - rect.width + (vWidth + hWidth) * 2;
          let overflow = true;
          if (frozenGroupAreas[FrozenGroupArea.Col].width >= pointX - newScroll.scrollX - hWidth * 2 || frozenGroupAreas[FrozenGroupArea.Row].height >= pointY - newScroll.scrollY - vWidth * 2 || rect.width <= pointX - newScroll.scrollX - hWidth * 2 || rect.height <= pointY - newScroll.scrollY + frozenGroupAreas[FrozenGroupArea.Row].height) {
            overflow = true;
          } else {
            overflow = false;
          }
          scroll.value = __spreadProps(__spreadValues({}, newScroll), {
            overflow,
            width: 8 - (pointWidth > 0 ? pointWidth : 0)
          });
        } else {
          scroll.value = { scrollX: -999, scrollY: -999, overflow: true };
        }
      }
    };
    const fixPosition = (event) => {
      const spreadsheet = s2Ref.value;
      if (!spreadsheet) {
        return;
      }
      const eventCell = spreadsheet.getCell(event.target);
      const isEventCellSelected = spreadsheet.interaction.isSelectedCell(
        eventCell
      );
      if (isEventCellSelected) {
        cell.value = eventCell;
      } else {
        cell.value = void 0;
      }
    };
    const batchSelected = () => {
      cell.value = void 0;
    };
    const onCopyFinished = () => {
      batchSelected();
    };
    const bindEvents = () => {
      const spreadsheet = s2Ref.value;
      if (!spreadsheet) {
        return;
      }
      spreadsheet.on(S2Event.COL_CELL_CLICK, batchSelected);
      spreadsheet.on(S2Event.ROW_CELL_CLICK, batchSelected);
      spreadsheet.on(S2Event.CORNER_CELL_CLICK, batchSelected);
      spreadsheet.on(S2Event.DATA_CELL_BRUSH_SELECTION, batchSelected);
      spreadsheet.on(S2Event.DATA_CELL_CLICK, fixPosition);
      spreadsheet.on(S2Event.GLOBAL_SCROLL, handleScroll);
    };
    const unbindEvents = () => {
      const spreadsheet = s2Ref.value;
      if (!spreadsheet) {
        return;
      }
      spreadsheet.off(S2Event.COL_CELL_CLICK, batchSelected);
      spreadsheet.off(S2Event.ROW_CELL_CLICK, batchSelected);
      spreadsheet.off(S2Event.CORNER_CELL_CLICK, batchSelected);
      spreadsheet.off(S2Event.DATA_CELL_BRUSH_SELECTION, batchSelected);
      spreadsheet.off(S2Event.DATA_CELL_CLICK, fixPosition);
      spreadsheet.off(S2Event.GLOBAL_SCROLL, handleScroll);
    };
    watch(cell, () => {
      handleScroll();
    });
    watch([scroll, cell], () => {
      var _a, _b;
      const spreadsheet = s2Ref.value;
      if (!(spreadsheet == null ? void 0 : spreadsheet.getCanvasElement())) {
        return;
      }
      if (spreadsheet && cell.value) {
        const sampleColNode = spreadsheet.facet.getColNodes()[0];
        const sampleColNodeHeight = (sampleColNode == null ? void 0 : sampleColNode.height) || 0;
        const cellMeta = pick(cell.value.getMeta(), [
          "x",
          "y",
          "width",
          "height",
          "fieldValue"
        ]);
        cellMeta.x -= (_a = scroll.value) == null ? void 0 : _a.scrollX;
        cellMeta.y -= ((_b = scroll.value) == null ? void 0 : _b.scrollY) - sampleColNodeHeight;
        position.value = {
          left: cellMeta.x + cellMeta.width - 4,
          top: cellMeta.y + cellMeta.height - 4
        };
      }
    });
    watch(
      () => {
        var _a, _b;
        return [
          (_a = s2Ref.value) == null ? void 0 : _a.dataSet.sortParams,
          (_b = s2Ref.value) == null ? void 0 : _b.dataSet.filterParams
        ];
      },
      () => {
        if (cell.value) {
          cell.value = void 0;
        }
      }
    );
    watch(
      s2Ref,
      (newS2, oldS2) => {
        if (oldS2) {
          oldS2.off(S2Event.COL_CELL_CLICK, batchSelected);
          oldS2.off(S2Event.ROW_CELL_CLICK, batchSelected);
          oldS2.off(S2Event.CORNER_CELL_CLICK, batchSelected);
          oldS2.off(S2Event.DATA_CELL_BRUSH_SELECTION, batchSelected);
          oldS2.off(S2Event.DATA_CELL_CLICK, fixPosition);
          oldS2.off(S2Event.GLOBAL_SCROLL, handleScroll);
        }
        if (newS2) {
          bindEvents();
        }
      },
      { immediate: true }
    );
    onUnmounted(() => {
      unbindEvents();
    });
    const pointStyle = computed(() => ({
      display: scroll.value.overflow ? "none" : "block",
      left: `${position.value.left}px`,
      top: `${position.value.top}px`,
      width: `${scroll.value.width}px`
    }));
    return {
      S2_PREFIX_CLS,
      pointStyle,
      onCopyFinished
    };
  }
});
export {
  _sfc_main as default
};
//# sourceMappingURL=DragCopyPoint.vue2.js.map
