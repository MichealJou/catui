"use strict";
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const s2 = require("@antv/s2");
const lodash = require("lodash");
const vue = require("vue");
const SpreadSheetContext = require("../../../../context/SpreadSheetContext.js");
;/* empty css                     */
const _sfc_main = vue.defineComponent({
  name: "DragCopyMask",
  props: {
    onCopyFinished: {
      type: Function,
      default: void 0
    }
  },
  setup(props) {
    const s2Ref = SpreadSheetContext.useSpreadSheetInstance();
    const startCell = vue.ref();
    const maskPosition = vue.ref({ right: 0, bottom: 0 });
    const dragPoint = vue.ref();
    const lastHoverPoint = { x: 0, y: 0 };
    const isInCell = (point, cell) => {
      const s22 = s2Ref.value;
      if (!s22) {
        return false;
      }
      const cellMeta = lodash.pick(cell.getMeta(), [
        "x",
        "y",
        "width",
        "height",
        "fieldValue"
      ]);
      const scrollOffset = s22.facet.getScrollOffset();
      const sampleColNode = s22.facet.getColNodes()[0];
      const sampleColNodeHeight = (sampleColNode == null ? void 0 : sampleColNode.height) || 0;
      const pointX = point.x;
      const pointY = point.y;
      const scrollOffsetY = (scrollOffset == null ? void 0 : scrollOffset.scrollY) - sampleColNodeHeight;
      const cellMaxX = cellMeta.x - scrollOffset.scrollX + cellMeta.width + 4;
      const cellMinX = cellMeta.x - scrollOffset.scrollX;
      const cellMaxY = cellMeta.y - scrollOffsetY + cellMeta.height + 4;
      const cellMinY = cellMeta.y - scrollOffsetY;
      return cellMaxX >= pointX && cellMinX < pointX && cellMaxY >= pointY && cellMinY < pointY;
    };
    const judgePointInView = (point) => {
      const s2$1 = s2Ref.value;
      if (!s2$1) {
        return false;
      }
      const rect = s2$1.getCanvasElement().getBoundingClientRect();
      const frozenGroupAreas = s2$1.facet.frozenGroupAreas;
      const viewMinX = rect.x;
      const viewMaxX = rect.x + rect.width;
      const viewMinY = rect.y + frozenGroupAreas[s2.FrozenGroupArea.Row].height;
      const viewMaxY = rect.y + rect.height;
      return point.x <= viewMaxX && point.x >= viewMinX && point.y <= viewMaxY && point.y >= viewMinY;
    };
    const getCurrentHoverCell = (event) => {
      const s22 = s2Ref.value;
      if (!s22) {
        return void 0;
      }
      const rect = s22.getCanvasElement().getBoundingClientRect();
      const allCells = s22.facet.getDataCells();
      return allCells.find(
        (dataCell) => isInCell({ y: event.y - rect.y, x: event.x - rect.x }, dataCell)
      );
    };
    const getSelectedCellRange = (start, end) => {
      const s22 = s2Ref.value;
      if (!s22) {
        return [];
      }
      const startCellMeta = start.getMeta();
      const endCellMeta = end == null ? void 0 : end.getMeta();
      const minX = Math.min(startCellMeta.colIndex, endCellMeta.colIndex);
      const maxX = Math.max(startCellMeta.colIndex, endCellMeta.colIndex);
      const maxY = Math.max(startCellMeta.rowIndex, endCellMeta.rowIndex);
      const minY = Math.min(startCellMeta.rowIndex, endCellMeta.rowIndex);
      const allCells = s22.facet.getDataCells();
      return allCells.filter((item) => {
        const itemMeta = item.getMeta();
        return itemMeta.rowIndex <= maxY && itemMeta.rowIndex >= minY && itemMeta.colIndex <= maxX && itemMeta.colIndex >= minX;
      });
    };
    const dragMove = lodash.throttle((event) => {
      const s2$1 = s2Ref.value;
      if (!startCell.value || !s2$1) {
        return;
      }
      let targetCell = getCurrentHoverCell(event);
      let newX = event.x - dragPoint.value.x;
      let newY = event.y - dragPoint.value.y;
      if (!judgePointInView(event)) {
        targetCell = getCurrentHoverCell(lastHoverPoint);
        newX = lastHoverPoint.x - dragPoint.value.x;
        newY = lastHoverPoint.y - dragPoint.value.y;
      } else {
        lastHoverPoint.x = event.x;
        lastHoverPoint.y = event.y;
      }
      maskPosition.value = { right: newX, bottom: newY };
      const selectedRange = getSelectedCellRange(startCell.value, targetCell);
      s2$1.interaction.changeState({
        cells: selectedRange.map((v) => v.getMeta()),
        stateName: s2.InteractionStateName.PREPARE_SELECT,
        force: true
      });
    }, 10);
    const dragMouseUp = (event) => __async(this, null, function* () {
      var _a;
      const s2$1 = s2Ref.value;
      if (!startCell.value || !s2$1) {
        return;
      }
      const targetCell = getCurrentHoverCell(event) || getCurrentHoverCell(lastHoverPoint);
      const displayData = s2$1.dataSet.getDisplayDataSet();
      const selectedRange = getSelectedCellRange(startCell.value, targetCell);
      const { fieldValue } = startCell.value.getMeta();
      const changedCells = selectedRange.map((item) => {
        const { rowIndex, valueField } = item.getMeta();
        if (displayData[rowIndex] && typeof displayData[rowIndex][valueField] !== "undefined") {
          displayData[rowIndex][valueField] = fieldValue;
        }
        return item;
      });
      s2$1.interaction.changeState({
        cells: changedCells.map((v) => v.getMeta()),
        stateName: s2.InteractionStateName.PREPARE_SELECT,
        force: true
      });
      yield s2$1.render(true);
      maskPosition.value = { right: 0, bottom: 0 };
      s2$1.off(s2.S2Event.GLOBAL_MOUSE_MOVE, dragMove);
      s2$1.off(s2.S2Event.GLOBAL_MOUSE_UP, dragMouseUp);
      startCell.value = void 0;
      (_a = props.onCopyFinished) == null ? void 0 : _a.call(props);
    });
    const dragMouseDown = (event) => {
      const s22 = s2Ref.value;
      if (!s22) {
        return;
      }
      if (lodash.get(event, "target.id") !== "spreadsheet-drag-copy-point") {
        return;
      }
      const rect = event.target.getBoundingClientRect();
      const { top, left } = lodash.get(event, "target.style", {});
      const allCells = s22.facet.getDataCells();
      const targetCell = allCells.find(
        (v) => isInCell({ y: parseFloat(top), x: parseFloat(left) }, v)
      );
      dragPoint.value = { x: rect.x, y: rect.y };
      startCell.value = targetCell;
    };
    vue.watch(startCell, (cell) => {
      const s2$1 = s2Ref.value;
      if (cell && s2$1) {
        s2$1.on(s2.S2Event.GLOBAL_MOUSE_MOVE, dragMove);
        s2$1.on(s2.S2Event.GLOBAL_MOUSE_UP, dragMouseUp);
      }
    });
    vue.onMounted(() => {
      const pointElement = document.getElementById(
        "spreadsheet-drag-copy-point"
      );
      pointElement == null ? void 0 : pointElement.addEventListener("mousedown", dragMouseDown);
    });
    vue.onUnmounted(() => {
      const pointElement = document.getElementById(
        "spreadsheet-drag-copy-point"
      );
      pointElement == null ? void 0 : pointElement.removeEventListener("mousedown", dragMouseDown);
    });
    return {
      S2_PREFIX_CLS: s2.S2_PREFIX_CLS,
      maskPosition
    };
  }
});
module.exports = _sfc_main;
//# sourceMappingURL=DragCopyMask.vue.js.map
